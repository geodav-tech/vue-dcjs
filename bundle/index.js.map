{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../src/mixins/axis.mixin.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../node_modules/vue-runtime-helpers/dist/inject-style/browser.mjs","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../src/mixins/dimension.mixin.vue","../src/mixins/group.mixin.vue","../src/mixins/legend.mixin.vue","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      this._theAxis = d3[type]()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this._minHeight = 0\n    this._defaultHeightCalc = el => 24\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\nconst renderAllNoTransitions = () => {\n  dc.chartRegistry.list().forEach(chart => {\n    // this will set the transition duration to 0 while we render\n    // this makes the resize less flashy/distracting\n    let lastTransitionDuration = chart.transitionDuration()\n    chart.transitionDuration(0)\n    if (chart.vueRender) { // if this is a vue-dc chart we can override with a custom render function to accomplish certain fixes\n      chart.vueRender()\n    } else {\n      chart.render()\n    }\n    // but then put the duration back to whatever it was before the render\n    chart.transitionDuration(lastTransitionDuration)\n  })\n}\n\n// assign extras via Object.assign to prevent module mutated warning\nObject.assign(dc, { AxisChart,  renderAllNoTransitions })\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => {\n    return document.querySelector(chart.anchor()).closest('.example-container')?.querySelectorAll('.example-reset-button') || []\n  },\n  titleRoundDigits: -1,\n}\n\nlet dcConfig = Object.assign({}, defaultOptions)\nconst setOptions = (options) => { dcConfig = options }\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    setOptions(options)\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      let lastWidth = window.innerWidth\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        if (lastWidth !== window.innerWidth) {\n          resizeTimeout = setTimeout(() => {\n            dc.renderAllNoTransitions()\n            resizeTimeout = null\n            lastWidth = window.innerWidth\n          }, options.resizeTimeout)\n        }\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter, dcConfig, setOptions }\n","<script>\nexport default {\n  props: {\n    /**\n     * x: AxisOptions,\n     * y: AxisOptions,\n     *\n     * AxisOptions: {\n     *  x: scale,\n     *  y: scale,\n     *  ticks: number,\n     *  format: string, number | d => value,\n     *  values: number[],\n     *  size: number\n     * }\n     */\n    axisOptions: {\n      // can also be in this.options\n      type: Object\n    }\n  },\n  data () {\n    return {\n      autoTickHandler: null\n    }\n  },\n  methods: {\n    applyAxisOptions() {\n      let xAxisOptions = this.computedAxisOptions.x\n      let yAxisOptions = this.computedAxisOptions.y\n      if (!this.chart || (!xAxisOptions && !yAxisOptions)) {\n        // nothing to apply to, or nothing to apply\n        return\n      }\n      const xAxis = this.chart.xAxis?.()\n      const yAxis = this.chart.yAxis?.()\n\n      const applyTicks = (axis, ticks) => {\n        if (ticks || ticks === 0) {\n          axis.ticks(ticks)\n        }\n      }\n\n      const applyFormat = (axis, format) => {\n        if (typeof format === 'string') {\n          axis.tickFormat(this.$d3.format(format))\n        } else if (typeof format === 'number') {\n          axis.tickFormat = this.$d3.format(`,.${format}f`)\n        } else if (typeof format === 'function') {\n          axis.tickFormat(format)\n        }\n      }\n\n      const applyValues = (axis, values) => {\n        if (values && Array.isArray(values)) {\n          axis.tickValues(values)\n        }\n      }\n\n      const applySize = (axis, size) => {\n        if (size || size === 0) {\n          axis.tickSize(size)\n        }\n      }\n\n      if (xAxisOptions && xAxis) {\n        applyTicks(xAxis, xAxisOptions.ticks)\n        applyFormat(xAxis, xAxisOptions.format)\n        applyValues(xAxis, xAxisOptions.values)\n        applySize(xAxis, xAxisOptions.size)\n        if (xAxisOptions.tilt) {\n          this.$d3.select(this.chart.anchor()).classed('tilted-x-axis', true)\n        }\n        if (xAxisOptions.x && typeof this.chart.x === 'function') {\n          this.chart.x(xAxisOptions.x(this.$options.dimension))\n        }\n      }\n\n      if (yAxisOptions && yAxis) {\n        applyTicks(yAxis, yAxisOptions.ticks)\n        applyFormat(yAxis, yAxisOptions.format)\n        applyValues(yAxis, yAxisOptions.values)\n        applySize(yAxis, yAxisOptions.size)\n        if (yAxisOptions.y && typeof this.chart.y === 'function') {\n          this.chart.y(yAxisOptions.y(this.$options.dimension))\n        }\n      }\n\n      if (yAxis && this.computedAxisOptions.autoTicks && this.ndx) {\n        this.ndx.onChange(evt => {\n          if (evt === 'filtered') {\n            const maxTicks = Math.max(yAxisOptions?.ticks || 0, 10)\n            const valueAccessor = this.chart?.valueAccessor()\n            const group = this.chart?.group()\n            const top = group?.top?.(1)?.[0]\n            let maxValue = maxTicks\n            try {\n              maxValue = Math.ceil(valueAccessor(top))\n            } catch {\n              maxValue = maxTicks\n            }\n            const ticks = Math.min(maxTicks, Math.max(1, maxValue))\n            yAxis.ticks(ticks)\n          }\n        })\n      }\n    }\n  },\n  computed: {\n    computedAxisOptions() {\n      return {\n        x: Object.assign({}, this.computedOptions?.xAxis, this.axisOptions?.x),\n        y:  Object.assign({}, this.computedOptions?.yAxis, this.axisOptions?.y),\n        autoTicks: this.computedOptions?.autoTicks || this.axisOptions?.autoTicks || false\n      }\n    }\n  },\n  beforeDestroy () {\n    if (this.autoTickHandler) {\n      this.autoTickHandler()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.tilted-x-axis .axis.x .tick text{\n  text-anchor: end;\n  transform: rotate(-33deg) translate(-4px, -2px);\n}\n\n</style>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","const isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nexport default createInjector;\n//# sourceMappingURL=browser.mjs.map\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc (accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain (target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat (array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nimport { dcConfig } from '../plugins/dc.plugin.js'\n\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  myName: 'baseChart',\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: []\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    async drawChart() {\n      // clear chart?\n      await this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (dcConfig.useResetListener && typeof dcConfig.resetSelector === 'function') {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width, digits, titleSuffix } = this.computedOptions\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = keyAccessor ? accessorFunc(keyAccessor)(d) : d.key\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins && this.chart.margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n\n      // allow our custom `renderAllNoTransitions` to call the overridden render func for vue-based charts\n      this.chart.vueRender = () => this.render()\n    },\n    onResetButtonClick() {},\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.computedOptions?.onCreate?.(this.chart)\n      this.$emit('create', this.chart)\n    },\n    setupResetListener() {\n      let charts = this.chart?.children ? [this.chart, ...this.chart.children()] : [this.chart]\n      try {\n        const { resetSelector } = dcConfig\n        this.resetButtons = charts.reduce((buttons, chart) => {\n          let result = resetSelector(chart)\n          if (typeof result.forEach !== 'function') {\n            buttons.push(result)\n          } else {\n            result.forEach((res) => {\n              buttons.push(res)\n            })\n          }\n          return buttons\n        }, [])\n\n        // ensure we can remove this later\n        this.resetButtonFunction = () => {\n          charts.forEach((chart) => {\n            chart.filterAll()\n          })\n          this.$dc.redrawAll()\n        }\n\n        this.resetButtons.forEach((button) => {\n          button.addEventListener('click', this.resetButtonFunction)\n        })\n        const updateButtonVisibility = () => {\n          let hasFilter = charts.some((chart) => chart.hasFilter())\n          this.resetButtons.forEach((instance) => {\n            if (hasFilter) {\n              instance.classList.remove('dc-reset-is-hidden')\n            } else {\n              instance.classList.add('dc-reset-is-hidden')\n            }\n          })\n        }\n\n        charts.forEach((chart) => {\n          chart.on('filtered.reset', updateButtonVisibility)\n        })\n        updateButtonVisibility() // update this on startup as well\n      } catch (e) {\n        console.error('Could not attach reset listener using resetSelector', e)\n      }\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","<script>\nexport default {\n  name: 'DimensionMixin',\n  props: {\n    dimensionConstructor: {\n      type: [String, Function] // (d) => value\n    },\n    dimensionIsArray: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    createDimension() {\n      let dimensionAccessor = (d) => d\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    }\n  }\n}\n</script>\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'GroupMixin',\n  props: {\n    reducer: {\n      type: [String, Function, Object]\n    },\n    groupOptions: {\n      /**\n       * order: d => orderValue,\n       * orderNatural: boolean (not compatable with order),\n       */\n      type: Object\n    }\n  },\n  methods: {\n    createGroup(dimension, groupAll = false) {\n      let group = groupAll ? dimension.groupAll() : dimension.group()\n\n      if (this.groupOptions && this.groupOptions.order) {\n        if (typeof this.groupOptions.order === 'string') {\n          group.order((d) => d[this.groupOptions.order])\n        } else if (typeof this.groupOptions.order === 'function') {\n          group.order(this.groupOptions.order)\n        }\n      } else if (this.groupOptions && this.groupOptions.orderNatural) {\n        group.orderNatural()\n      }\n\n      if (typeof this.reducer === 'string' || typeof this.reducer === 'function') {\n        group.reduceSum(accessorFunc(this.reducer))\n      } else if (this.reducer.add && this.reducer.remove && this.reducer.init) {\n        let { add, remove, init } = this.reducer\n        group.reduce(add, remove, init)\n      }\n      return new Promise((resolve, reject) => {\n        let resolveTimeout = setTimeout(() => {\n          return resolve(group)\n        })\n        this.$emit('group-created', group, (replaceGroup) => {\n          // parent called back with a replacement\n          clearTimeout(resolveTimeout)\n          return resolve(replaceGroup)\n        })\n      })\n    },\n    // https://github.com/dc-js/dc.js/blob/develop/web-src/examples/focus-ordinal-bar.html\n    ordinalToLinear(group, valueFunc, isGroupAll = false) {\n      var _ord2int, _int2ord\n      return {\n        top: function (number = 1) {\n          if (isGroupAll) {\n            return Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n              .slice(0, number)\n          } else {\n            return group.order((d) => valueFunc(d)).top(number)\n          }\n        },\n        all: function () {\n          var ret = []\n          if (isGroupAll) {\n            ret = Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n          } else {\n            ret = group.order((d) => valueFunc(d)).top(Infinity)\n          }\n          _ord2int = {}\n          _int2ord = []\n          ret.forEach(function (d, i) {\n            _ord2int[d.key] = i\n            _int2ord[i] = d.key\n          })\n          return ret\n        },\n        ord2int: function (o) {\n          if (!_ord2int) {\n            this.all()\n          }\n          return _ord2int[o]\n        },\n        int2ord: function (i) {\n          if (!_int2ord) {\n            this.all()\n          }\n          return _int2ord[i]\n        }\n      }\n    }\n  }\n}\n</script>\n","<script>\nexport default {\n  props: {\n    legend: {\n      type: Boolean\n    },\n    legendOptions: {\n      type: Object\n    }\n  },\n  methods: {\n    applyLegendOptions() {\n      if (this.computedOptions.showLegend || this.computedOptions.legend || this.legend) {\n        let legend = this.$dc.legend()\n        let {\n          autoWidth,\n          gap,\n          highlightSelected,\n          horizontal,\n          itemHeight,\n          itemWidth,\n          keyboardAccessible,\n          legendText,\n          legendWidth,\n          maxItems,\n          x,\n          y\n        } = this.computedLegendOptions\n\n        // use !== undefined to allow false/0 values to be accepted\n\n        if (autoWidth !== undefined) {\n          legend.autoItemWidth(autoWidth)\n        } else if (itemWidth !== undefined) {\n          legend.itemWidth(itemWidth)\n        }\n\n        if (gap !== undefined) {\n          legend.gap(gap)\n        }\n\n        if (highlightSelected !== undefined) {\n          legend.highlightSelected(highlightSelected)\n        }\n\n        if (horizontal !== undefined) {\n          legend.horizontal(horizontal)\n        }\n        if (itemHeight !== undefined) {\n          legend.itemHeight(itemHeight)\n        }\n\n        if (keyboardAccessible !== undefined) {\n          legend.keyboardAccessible(keyboardAccessible)\n        }\n\n        if (legendText !== undefined) {\n          legend.legendText(legendText)\n        }\n        if (legendWidth !== undefined) {\n          legend.legendWidth(legendWidth)\n        }\n        if (maxItems !== undefined) {\n          legend.maxItems(maxItems)\n        }\n        if (x !== undefined) {\n          legend.x(x)\n        }\n        if (y !== undefined) {\n          legend.y(y)\n        }\n        this.chart.legend(legend)\n      }\n    }\n  },\n  computed: {\n    computedLegendOptions() {\n      return Object.assign({}, this.defaultOptions?.legendOptions, this.options?.legendOptions, this.legendOptions)\n    }\n  }\n}\n</script>\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install (Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport * from './mixins'\nexport { VueDc, dc, d3, crossfilter }\nexport default VueDc\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","calculateAxisScale","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","drawAxis","axisG","_g","select","empty","append","attr","transition","transitionDuration","transitionDelay","call","_doRender","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","d3","console","error","elastic","axis","data","_doRedraw","constructor","parent","chartGroup","super","_defineProperty","axisBottom","_minHeight","_defaultHeightCalc","el","anchor","require","Object","assign","dc","renderAllNoTransitions","chartRegistry","list","forEach","chart","lastTransitionDuration","vueRender","render","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","document","querySelector","closest","querySelectorAll","titleRoundDigits","dcConfig","DcPlugin","install","Vue","_options","options","setOptions","defaultColors","config","prototype","$dc","$d3","$crossfilter","crossfilter","lastWidth","window","innerWidth","addEventListener","clearTimeout","setTimeout","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","isOldIE","navigator","test","userAgent","toLowerCase","id","css","group","media","styles","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","setAttribute","undefined","HEAD","head","getElementsByTagName","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","size","textNode","createTextNode","nodes","childNodes","removeChild","insertBefore","addStyle","accessorFunc","accessor","constrain","target","minValue","Infinity","maxValue","Math","max","min","array","Array","isArray","reduce","acc","val","registerComponents","VueDc","$super","Proxy","get","name","methods","bind","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}