{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/mixins/axis.mixin.vue","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../node_modules/vue-runtime-helpers/dist/inject-style/browser.mjs","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.minHeight(1)\n    this.height(50)\n    // idk why the minHeight, height kept getting reset\n    // so you must call these before resetSvg()\n    // otherwise the axisHeight is like 200px or 156px (depending on minHeight)\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      this._theAxis = d3[type]()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\ndc.AxisChart = AxisChart\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => document.querySelector(chart.anchor()).closest('.example-container').querySelectorAll('.example-reset-button')\n}\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n\n    Vue.prototype.$VueDcOptions = options // let us access these options later\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        resizeTimeout = setTimeout(() => {\n          dc.renderAll()\n          resizeTimeout = null\n        }, options.resizeTimeout)\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter }\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<script>\nexport default {\n  props: {\n    /**\n     * x: AxisOptions,\n     * y: AxisOptions,\n     *\n     * AxisOptions: {\n     *  x: scale,\n     *  y: scale,\n     *  ticks: number,\n     *  format: string, number | d => value,\n     *  values: number[],\n     *  size: number\n     * }\n     */\n    axisOptions: {\n      // can also be in this.options\n      type: Object\n    }\n  },\n  methods: {\n    applyAxisOptions() {\n      let xAxisOptions = this.computedAxisOptions.x\n      let yAxisOptions = this.computedAxisOptions.y\n      if (!this.chart || (!xAxisOptions && !yAxisOptions)) {\n        // nothing to apply to, or nothing to apply\n        return\n      }\n      const xAxis = this.chart.xAxis?.()\n      const yAxis = this.chart.yAxis?.()\n\n      const applyTicks = (axis, ticks) => {\n        if (ticks || ticks === 0) {\n          axis.ticks(ticks)\n        }\n      }\n\n      const applyFormat = (axis, format) => {\n        if (typeof format === 'string') {\n          axis.tickFormat(this.$d3.format(format))\n        } else if (typeof format === 'number') {\n          axis.tickFormat = this.$d3.format(`,.${format}f`)\n        } else if (typeof format === 'function') {\n          axis.tickFormat(format)\n        }\n      }\n\n      const applyValues = (axis, values) => {\n        if (values && Array.isArray(values)) {\n          axis.tickValues(values)\n        }\n      }\n\n      const applySize = (axis, size) => {\n        if (size || size === 0) {\n          axis.tickSize(size)\n        }\n      }\n\n      if (xAxisOptions && xAxis) {\n        applyTicks(xAxis, xAxisOptions.ticks)\n        applyFormat(xAxis, xAxisOptions.format)\n        applyValues(xAxis, xAxisOptions.values)\n        applySize(xAxis, xAxisOptions.size)\n        if (xAxisOptions.x && typeof this.chart.x === 'function') {\n          this.chart.x(xAxisOptions.x(this.$options.dimension))\n        }\n      }\n\n      if (yAxisOptions && yAxis) {\n        applyTicks(yAxis, yAxisOptions.ticks)\n        applyFormat(yAxis, yAxisOptions.format)\n        applyValues(yAxis, yAxisOptions.values)\n        applySize(yAxis, yAxisOptions.size)\n        if (yAxisOptions.y && typeof this.chart.y === 'function') {\n          this.chart.y(yAxisOptions.y(this.$options.dimension))\n        }\n      }\n    }\n  },\n  computed: {\n    computedAxisOptions() {\n      let options = { x: null, y: null }\n      if (this.computedOptions.xAxis) {\n        options.x = Object.assign({}, this.computedOptions.xAxis)\n      }\n      if (this.computedOptions.yAxis) {\n        options.y = Object.assign({}, this.computedOptions.yAxis)\n      }\n      if (this.axisOptions?.x) {\n        options.x = Object.assign({}, options.x, this.axisOptions.x)\n      }\n      if (this.axisOptions?.y) {\n        options.y = Object.assign({}, options.y, this.axisOptions.y)\n      }\n      return options\n    }\n  }\n}\n</script>\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc(accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain(target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat(array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  myName: 'baseChart',\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: [],\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    drawChart() {\n      // clear chart?\n      this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (this.$VueDcOptions.useResetListener && typeof this.$VueDcOptions.resetSelector === 'function') {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width } = this.computedOptions\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n    },\n    onResetButtonClick() {\n\n    },\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.$emit('on-create', this.chart)\n    },\n    setupResetListener () {\n      const { resetSelector } = this.$VueDcOptions\n      let resetButtons = resetSelector(this.chart)\n      if (typeof resetButtons.forEach !== 'function') {\n        resetButtons = [resetButtons]\n      }\n      this.resetButtons = resetButtons // store this for later to de-register\n\n      // ensure we can remove this later\n      this.resetButtonFunction = () => {\n        this.chart.filterAll()\n        this.$dc.redrawAll()\n      }\n\n      resetButtons.forEach(button => {\n        button.addEventListener('click', this.resetButtonFunction)\n      })\n\n      const updateButtonVisibility = () => {\n        let hasFilter = this.chart.hasFilter()\n        this.resetButtons.forEach(instance => {\n          if (hasFilter) {\n            instance.classList.remove('dc-reset-is-hidden')\n          } else {\n            instance.classList.add('dc-reset-is-hidden')\n          }\n        })\n      }\n\n      this.chart.on('filtered.reset', updateButtonVisibility)\n      updateButtonVisibility() // update this on startup as well\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","const isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nexport default createInjector;\n//# sourceMappingURL=browser.mjs.map\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport { VueDc, dc, d3, crossfilter }\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","parent","chartGroup","axisBottom","anchor","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","_this2","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","axisG","_g","select","calculateAxisScale","empty","append","attr","transition","transitionDuration","transitionDelay","call","minHeight","height","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","d3","console","error","elastic","data","drawAxis","require","dc","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","chart","document","querySelector","closest","querySelectorAll","DcPlugin","install","Vue","_options","options","Object","assign","prototype","$VueDcOptions","defaultColors","config","$dc","$d3","$crossfilter","crossfilter","window","addEventListener","clearTimeout","setTimeout","renderAll","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","accessorFunc","accessor","constrain","target","minValue","Infinity","maxValue","Math","max","min","isOldIE","navigator","test","userAgent","toLowerCase","id","css","group","media","styles","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","setAttribute","undefined","HEAD","head","getElementsByTagName","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","size","textNode","createTextNode","nodes","childNodes","removeChild","insertBefore","addStyle","array","Array","isArray","reduce","acc","val","registerComponents","VueDc","$super","Proxy","get","name","methods","bind","_this","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}