{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../src/mixins/axis.mixin.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../node_modules/vue-runtime-helpers/dist/inject-style/browser.mjs","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../src/mixins/dimension.mixin.vue","../src/mixins/group.mixin.vue","../src/mixins/legend.mixin.vue","../src/components/dc-bar-chart/dc-bar-chart.vue","../src/components/dc-checklist/dc-checklist.vue","../src/components/dc-composite-line-chart/dc-composite-line-chart.vue","../src/components/dc-date-chart/dc-date-chart.vue","../src/components/dc-number-display/dc-number-display.vue","../src/components/dc-pie-chart/dc-pie-chart.vue","../src/components/dc-row-chart/dc-row-chart.vue","../src/components/dc-stacked-bar-chart/dc-stacked-bar-chart.vue","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, axisLeft, axisRight, axisTop, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      const axis = { axisBottom, axisTop, axisRight, axisLeft }[type]\n      this._theAxis = axis()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this._minHeight = 0\n    this._defaultHeightCalc = () => 24\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\nconst renderAllNoTransitions = () => {\n  dc.chartRegistry.list().forEach(chart => {\n    // this will set the transition duration to 0 while we render\n    // this makes the resize less flashy/distracting\n    let lastTransitionDuration = chart.transitionDuration()\n    chart.transitionDuration(0)\n    if (chart.vueRender) { // if this is a vue-dc chart we can override with a custom render function to accomplish certain fixes\n      chart.vueRender()\n    } else {\n      chart.render()\n    }\n    // but then put the duration back to whatever it was before the render\n    chart.transitionDuration(lastTransitionDuration)\n  })\n}\n\n// assign extras via Object.assign to prevent module mutated warning\n// eslint-disable-next-line no-import-assign\nObject.assign(dc, { AxisChart,  renderAllNoTransitions })\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => {\n    return document.querySelector(chart.anchor())?.closest('.example-container')?.querySelectorAll('.example-reset-button') || []\n  },\n  titleRoundDigits: -1,\n}\n\nlet dcConfig = Object.assign({}, defaultOptions)\nconst setOptions = (options) => { dcConfig = options }\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    setOptions(options)\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      let lastWidth = window.innerWidth\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        if (lastWidth !== window.innerWidth) {\n          resizeTimeout = setTimeout(() => {\n            dc.renderAllNoTransitions()\n            resizeTimeout = null\n            lastWidth = window.innerWidth\n          }, options.resizeTimeout)\n        }\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter, dcConfig, setOptions }\n","<script>\nexport default {\n  props: {\n    /**\n     * x: AxisOptions,\n     * y: AxisOptions,\n     *\n     * AxisOptions: {\n     *  x: scale,\n     *  y: scale,\n     *  ticks: number,\n     *  format: string, number | d => value,\n     *  values: number[],\n     *  size: number\n     * }\n     */\n    axisOptions: {\n      // can also be in this.options\n      type: Object\n    }\n  },\n  data () {\n    return {\n      autoTickHandler: null\n    }\n  },\n  methods: {\n    applyAxisOptions() {\n      let xAxisOptions = this.computedAxisOptions.x\n      let yAxisOptions = this.computedAxisOptions.y\n      if (!this.chart || (!xAxisOptions && !yAxisOptions)) {\n        // nothing to apply to, or nothing to apply\n        return\n      }\n      const xAxis = this.chart.xAxis?.()\n      const yAxis = this.chart.yAxis?.()\n\n      const applyTicks = (axis, ticks) => {\n        if (ticks || ticks === 0) {\n          axis.ticks(ticks)\n        }\n      }\n\n      const applyFormat = (axis, format) => {\n        if (typeof format === 'string') {\n          axis.tickFormat(this.$d3.format(format))\n        } else if (typeof format === 'number') {\n          axis.tickFormat = this.$d3.format(`,.${format}f`)\n        } else if (typeof format === 'function') {\n          axis.tickFormat(format)\n        }\n      }\n\n      const applyValues = (axis, values) => {\n        if (values && Array.isArray(values)) {\n          axis.tickValues(values)\n        }\n      }\n\n      const applySize = (axis, size) => {\n        if (size || size === 0) {\n          axis.tickSize(size)\n        }\n      }\n\n      if (xAxisOptions && xAxis) {\n        applyTicks(xAxis, xAxisOptions.ticks)\n        applyFormat(xAxis, xAxisOptions.format)\n        applyValues(xAxis, xAxisOptions.values)\n        applySize(xAxis, xAxisOptions.size)\n        if (xAxisOptions.tilt) {\n          this.$d3.select(this.chart.anchor()).classed('tilted-x-axis', true)\n        }\n        if (xAxisOptions.x && typeof this.chart.x === 'function') {\n          this.chart.x(xAxisOptions.x(this.$options.dimension))\n        }\n      }\n\n      if (yAxisOptions && yAxis) {\n        applyTicks(yAxis, yAxisOptions.ticks)\n        applyFormat(yAxis, yAxisOptions.format)\n        applyValues(yAxis, yAxisOptions.values)\n        applySize(yAxis, yAxisOptions.size)\n        if (yAxisOptions.y && typeof this.chart.y === 'function') {\n          this.chart.y(yAxisOptions.y(this.$options.dimension))\n        }\n      }\n\n      if (yAxis && this.computedAxisOptions.autoTicks && this.ndx) {\n        this.ndx.onChange(evt => {\n          if (evt === 'filtered') {\n            const maxTicks = Math.max(yAxisOptions?.ticks || 0, 10)\n            const valueAccessor = this.chart?.valueAccessor()\n            const group = this.chart?.group()\n            const top = group?.top?.(1)?.[0]\n            let maxValue = maxTicks\n            try {\n              maxValue = Math.ceil(valueAccessor(top))\n            } catch {\n              maxValue = maxTicks\n            }\n            const ticks = Math.min(maxTicks, Math.max(1, maxValue))\n            yAxis.ticks(ticks)\n          }\n        })\n      }\n    }\n  },\n  computed: {\n    computedAxisOptions() {\n      return {\n        x: Object.assign({}, this.computedOptions?.xAxis, this.axisOptions?.x),\n        y:  Object.assign({}, this.computedOptions?.yAxis, this.axisOptions?.y),\n        autoTicks: this.computedOptions?.autoTicks || this.axisOptions?.autoTicks || false\n      }\n    }\n  },\n  beforeDestroy () {\n    if (this.autoTickHandler) {\n      this.autoTickHandler()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.tilted-x-axis .axis.x .tick text{\n  text-anchor: end;\n  transform: rotate(-33deg) translate(-4px, -2px);\n}\n\n</style>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","const isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nexport default createInjector;\n//# sourceMappingURL=browser.mjs.map\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc (accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain (target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat (array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nimport { dcConfig } from '../plugins/dc.plugin.js'\n\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  myName: 'baseChart',\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: []\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    async drawChart() {\n      // clear chart?\n      await this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (dcConfig.useResetListener && typeof dcConfig.resetSelector === 'function') {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width, digits, titleSuffix } = this.computedOptions\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = keyAccessor ? accessorFunc(keyAccessor)(d) : d.key\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins && this.chart.margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n\n      // allow our custom `renderAllNoTransitions` to call the overridden render func for vue-based charts\n      this.chart.vueRender = () => this.render()\n    },\n    onResetButtonClick() {},\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.computedOptions?.onCreate?.(this.chart)\n      this.$emit('create', this.chart)\n    },\n    setupResetListener() {\n      let charts = this.chart?.children ? [this.chart, ...this.chart.children()] : [this.chart]\n      try {\n        const { resetSelector } = dcConfig\n        this.resetButtons = charts.reduce((buttons, chart) => {\n          let result = resetSelector(chart)\n          if (typeof result.forEach !== 'function') {\n            buttons.push(result)\n          } else {\n            result.forEach((res) => {\n              buttons.push(res)\n            })\n          }\n          return buttons\n        }, [])\n\n        // ensure we can remove this later\n        this.resetButtonFunction = () => {\n          charts.forEach((chart) => {\n            chart.filterAll()\n          })\n          this.$dc.redrawAll()\n        }\n\n        this.resetButtons.forEach((button) => {\n          button.addEventListener('click', this.resetButtonFunction)\n        })\n        const updateButtonVisibility = () => {\n          let hasFilter = charts.some((chart) => chart.hasFilter())\n          this.resetButtons.forEach((instance) => {\n            if (hasFilter) {\n              instance.classList.remove('dc-reset-is-hidden')\n            } else {\n              instance.classList.add('dc-reset-is-hidden')\n            }\n          })\n        }\n\n        charts.forEach((chart) => {\n          chart.on('filtered.reset', updateButtonVisibility)\n        })\n        updateButtonVisibility() // update this on startup as well\n      } catch (e) {\n        console.error('Could not attach reset listener using resetSelector', e)\n      }\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","<script>\nexport default {\n  name: 'DimensionMixin',\n  props: {\n    dimensionConstructor: {\n      type: [String, Function] // (d) => value\n    },\n    dimensionIsArray: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    createDimension() {\n      let dimensionAccessor = (d) => d\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    }\n  }\n}\n</script>\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'GroupMixin',\n  props: {\n    reducer: {\n      type: [String, Function, Object]\n    },\n    groupOptions: {\n      /**\n       * order: d => orderValue,\n       * orderNatural: boolean (not compatable with order),\n       */\n      type: Object\n    }\n  },\n  methods: {\n    createGroup(dimension, groupAll = false) {\n      let group = groupAll ? dimension.groupAll() : dimension.group()\n\n      if (this.groupOptions && this.groupOptions.order) {\n        if (typeof this.groupOptions.order === 'string') {\n          group.order((d) => d[this.groupOptions.order])\n        } else if (typeof this.groupOptions.order === 'function') {\n          group.order(this.groupOptions.order)\n        }\n      } else if (this.groupOptions && this.groupOptions.orderNatural) {\n        group.orderNatural()\n      }\n\n      if (typeof this.reducer === 'string' || typeof this.reducer === 'function') {\n        group.reduceSum(accessorFunc(this.reducer))\n      } else if (this.reducer.add && this.reducer.remove && this.reducer.init) {\n        let { add, remove, init } = this.reducer\n        group.reduce(add, remove, init)\n      }\n      return new Promise((resolve, reject) => {\n        let resolveTimeout = setTimeout(() => {\n          return resolve(group)\n        })\n        this.$emit('group-created', group, (replaceGroup) => {\n          // parent called back with a replacement\n          clearTimeout(resolveTimeout)\n          return resolve(replaceGroup)\n        })\n      })\n    },\n    // https://github.com/dc-js/dc.js/blob/develop/web-src/examples/focus-ordinal-bar.html\n    ordinalToLinear(group, valueFunc, isGroupAll = false) {\n      var _ord2int, _int2ord\n      return {\n        top: function (number = 1) {\n          if (isGroupAll) {\n            return Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n              .slice(0, number)\n          } else {\n            return group.order((d) => valueFunc(d)).top(number)\n          }\n        },\n        all: function () {\n          var ret = []\n          if (isGroupAll) {\n            ret = Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n          } else {\n            ret = group.order((d) => valueFunc(d)).top(Infinity)\n          }\n          _ord2int = {}\n          _int2ord = []\n          ret.forEach(function (d, i) {\n            _ord2int[d.key] = i\n            _int2ord[i] = d.key\n          })\n          return ret\n        },\n        ord2int: function (o) {\n          if (!_ord2int) {\n            this.all()\n          }\n          return _ord2int[o]\n        },\n        int2ord: function (i) {\n          if (!_int2ord) {\n            this.all()\n          }\n          return _int2ord[i]\n        },\n        order: function(callback) {\n          if (isGroupAll) {\n            // if this is a groupAll, we'll have to manually figure this out\n            // generally this is used for dc-checklist\n            const order = Object.entries(group.value()).map(([key, value]) => ({ key, value })).sort((a, b) => callback(b.value) - callback(a.value))\n            // since we just turned the return into an array, we have to fake some dc functions we expect to use on the array\n            // dc-checklist uses top, but we'll also add .all in case\n            order.top = (num) => order.slice(0, num)\n            order.all = () => order\n            return order\n          } else {\n            // if this isn't a groupAll, it has an order function and you can just use that\n            return group.order(callback)\n          }\n        }\n      }\n    }\n  }\n}\n</script>\n","<script>\nexport default {\n  props: {\n    legend: {\n      type: Boolean\n    },\n    legendOptions: {\n      type: Object\n    }\n  },\n  methods: {\n    applyLegendOptions() {\n      if (this.computedOptions.showLegend || this.computedOptions.legend || this.legend) {\n        let legend = this.$dc.legend()\n        let {\n          autoWidth,\n          gap,\n          highlightSelected,\n          horizontal,\n          itemHeight,\n          itemWidth,\n          keyboardAccessible,\n          legendText,\n          legendWidth,\n          maxItems,\n          x,\n          y\n        } = this.computedLegendOptions\n\n        // use !== undefined to allow false/0 values to be accepted\n\n        if (autoWidth !== undefined) {\n          legend.autoItemWidth(autoWidth)\n        } else if (itemWidth !== undefined) {\n          legend.itemWidth(itemWidth)\n        }\n\n        if (gap !== undefined) {\n          legend.gap(gap)\n        }\n\n        if (highlightSelected !== undefined) {\n          legend.highlightSelected(highlightSelected)\n        }\n\n        if (horizontal !== undefined) {\n          legend.horizontal(horizontal)\n        }\n        if (itemHeight !== undefined) {\n          legend.itemHeight(itemHeight)\n        }\n\n        if (keyboardAccessible !== undefined) {\n          legend.keyboardAccessible(keyboardAccessible)\n        }\n\n        if (legendText !== undefined) {\n          legend.legendText(legendText)\n        }\n        if (legendWidth !== undefined) {\n          legend.legendWidth(legendWidth)\n        }\n        if (maxItems !== undefined) {\n          legend.maxItems(maxItems)\n        }\n        if (x !== undefined) {\n          legend.x(x)\n        }\n        if (y !== undefined) {\n          legend.y(y)\n        }\n        this.chart.legend(legend)\n      }\n    }\n  },\n  computed: {\n    computedLegendOptions() {\n      return Object.assign({}, this.defaultOptions?.legendOptions, this.options?.legendOptions, this.legendOptions)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-scroll-bar-chart-container\">\n    <div v-if=\"computedOptions.scrollable\" style=\"position: relative; z-index: 0\">\n      <div class=\"dc-scroll-bar-range\" :class=\"{ hidden: !canScroll }\" :id=\"`chart-${_uid}-range`\"></div>\n      <!-- fill in the scroll-bar space if we cannot scroll -->\n      <div class=\"dc-scroll-bar-range-filler\" :class=\"{ hidden: canScroll }\"></div>\n    </div>\n    <div class=\"dc-chart dc-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { AxisMixin, BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\nimport { dcConfig } from '../../plugins/dc.plugin.js'\n\nexport default {\n  name: 'DcBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: false,\n    minScrollable: 12, // will not scroll if less than this number\n    scrollHeight: 12, // how tall the scroll chart is\n    mouseZoom: true\n  },\n  data() {\n    return {\n      scaleChart: null,\n      top: 0,\n      hasReplacedRenderFunc: false\n    }\n  },\n  methods: {\n    async createChart() {\n      this.hasReplacedRenderFunc = false\n      let {\n        elastic,\n        minScrollable,\n        scrollHeight,\n        groupAll,\n        valueAccessor,\n        label,\n        title,\n        titleSuffix,\n        filterFunction,\n        mouseZoom,\n        barPadding,\n        barGap,\n        outerBarPadding,\n        digits\n      } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let ordinalValueAccessor = accessorFunc(valueAccessor || ((v) => v))\n      const group = this.ordinalToLinear(await this.createGroup(this.$options.dimension, groupAll), ordinalValueAccessor, groupAll)\n\n      this.top = group.all().length\n\n      const linearDomain = [-0.52, this.top - 0.5]\n      let defaultBarGap = this.top ? document.querySelector(`#chart-${this._uid}`).clientWidth / minScrollable / this.top : 0\n      defaultBarGap = Math.max(Math.ceil(defaultBarGap), 1)\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleLinear().domain(linearDomain))\n        .xUnits(this.$dc.units.integers)\n        .centerBar(true)\n        .brushOn(false)\n        .gap(defaultBarGap)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      this.chart.keyAccessor((kv) => group.ord2int(kv.key))\n      this.chart.valueAccessor((kv) => ordinalValueAccessor(kv.value))\n      this.chart.transitionDuration(this.canScroll ? 50 : 250)\n\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = d.key\n        // these require valueAccessor to pass d.value not d.... confusing\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d.value) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      let xAxisFormat = accessorFunc(this.computedAxisOptions.x?.format || (d => d))\n      this.chart.xAxis().tickFormat(d => xAxisFormat(group.int2ord(d))).ticks(this.top)\n      if (this.top <= minScrollable / 4) {\n        const l = this.top || 1\n        this.chart.barPadding(minScrollable / 2 / l)\n      }\n\n      let focusFilter = []\n      this.chart.filterHandler(function (dimension, filters) {}) // disable built in filtering\n\n      // overwrite with our own filtering logic\n      this.chart.hasFilter = function (f) {\n        if (Array.isArray(f)) {\n          return f.every((filter) => focusFilter.includes(filter))\n        } else if (f) {\n          return focusFilter.includes(f)\n        } else {\n          return focusFilter.length\n        }\n      }\n\n      this.chart.applyFilter = function () {\n        if (focusFilter.length) {\n          this.dimension().filterFunction(function (k) {\n            if (filterFunction) {\n              return filterFunction(focusFilter, k)\n            } else {\n              return focusFilter.includes(k)\n            }\n          })\n        } else {\n          this.dimension().filter(null)\n        }\n        // hook this custom filter logic back into the on('filtered') event handler\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this._listeners.call('filtered', this, this, focusFilter)\n      }\n\n      this.chart.filterAll = function () {\n        focusFilter = []\n        this.applyFilter()\n      }\n\n      // .filters now provides the actual keys as filters (dc-checklist support)\n      this.chart.filters = () => [...focusFilter]\n\n      // keep the original replaceFilter function for zoom settings\n      this.chart._originalReplaceFilter = this.chart.replaceFilter\n      this.chart.replaceFilter = function (filters) {\n        // replaceFilter can be called by the dc-checklist\n        // if everything is an array, it's a real request to replace filters the way we would expect\n        if (filters.every(filter => Array.isArray(filter))) {\n          focusFilter = []\n          // filters should look something like [['management', 'team2']] (double array)\n          filters.forEach(filter => {\n            // push inner array elements to the focus filter\n            focusFilter.push(...filter)\n          })\n          this.applyFilter() // apply the focus filter\n          return this // return the chart\n        } else {\n          // if this is not an array, then this is really a request to change the scroll area\n          return this._originalReplaceFilter(filters)\n        }\n      }\n\n      const dc = this.$dc\n      const d3 = this.$d3\n      this.chart.fadeDeselectedArea = function (brushSelection) {\n        let bars = this.chartBodyG().selectAll('rect.bar')\n        if (focusFilter.length) {\n          bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n            return focusFilter.includes(d.data.key)\n          })\n          bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n            return !focusFilter.includes(d.data.key)\n          })\n        } else {\n          bars.classed(dc.constants.SELECTED_CLASS, false)\n          bars.classed(dc.constants.DESELECTED_CLASS, false)\n        }\n      }\n\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart.selectAll('rect.bar').on('click.ordinal-select', function (e, d) {\n          var i = focusFilter.indexOf(d.data.key)\n          if (i >= 0) {\n            focusFilter.splice(i, 1)\n          } else {\n            focusFilter.push(d.data.key)\n          }\n          chart.applyFilter()\n          chart.redrawGroup()\n        })\n      })\n\n      this.chart.on('preRedraw.vue-dcjs', function (chart) {\n        const domain = chart.x().domain()\n        const min = Math.ceil(domain[0])\n        const max = Math.floor(domain[1])\n        chart.xAxis().tickValues(d3.range(min, max + 1))\n        chart.rescale() // allow x axis to match ordering changes\n      })\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      // FIXME text wrapping x axis in shared thing?\n\n      if (this.canScroll) {\n        let { top, bottom, left, right } = this.computedMargins\n        this.chart.margins({ top: 0, bottom, left, right })\n\n        // do not send focus events as filter events to anyone listening to this.chart.on('filtered')\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this.chart._invokeFilteredListener = function (f) {\n          // ignore 'RangedFilter' type. it's coming from the scale chart as long as brushing is disabled\n          if (f !== undefined && f.filterType !== 'RangedFilter') {\n            return this._listeners.call('filtered', this, this, f)\n          }\n        }\n\n        this.scaleChart = new this.$dc.BarChart(`#chart-${this._uid}-range`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(scrollHeight + top)\n          .margins({ left, top, right, bottom: 2 })\n          .x(this.$d3.scaleLinear().domain(linearDomain))\n          .xUnits(this.$dc.units.integers)\n          .keyAccessor((kv) => group.ord2int(kv.key))\n          .centerBar(true)\n          .valueAccessor((kv) => ordinalValueAccessor(kv.value))\n          .brushOn(true)\n          .transitionDuration(0)\n          .gap(1)\n\n        this.scaleChart.filterHandler(function () {}) // ensure the scale chart has no filterFunction (it will mess up scaling on all charts)\n        this.scaleChart.yAxis().ticks(0)\n        this.scaleChart.xAxis().ticks(0)\n\n        this.chart.rangeChart(this.scaleChart)\n        this.chart.zoomScale([Math.min(8, Math.ceil(this.top / 12)), Math.min(this.top, 12)])\n        if (elastic) {\n          this.scaleChart.elasticY(true)\n        }\n        if (mouseZoom) {\n          this.chart.mouseZoomable(this.canScroll)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      if (this.canScroll) {\n        if (!this.hasReplacedRenderFunc) {\n          // Calling `dc.renderAll()` messed up mouse zooming with this chart\n          // so this fixes things when using the window resize handler which calls dc.renderAll() to resize the charts\n          // rewriting this function without `this._configureMouseZoom()` seems to work?\n          // http://dc-js.github.io/dc.js/docs/html/base_coordinate-grid-mixin.js.html#sunlight-1-line-1150\n          // https://github.com/dc-js/dc.js/issues/1857\n          this.chart._doRender = function () {\n            this.resetSvg()\n            this._preprocessData()\n            this._generateG()\n            this._generateClipPath()\n            this._drawChart(true)\n            return this\n          }\n          this.hasReplacedRenderFunc = true\n        }\n        this.scaleChart?.render()\n        const maxEnd = Math.min(12, Math.floor(this.top / Math.min(8, Math.ceil(this.top / 12))))\n        this.chart.focus([-1, maxEnd])\n      }\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.scaleChart)\n      this.$emit('create', this.chart, this.scaleChart)\n    }\n  },\n  computed: {\n    canScroll() {\n      return this.computedOptions.scrollable && this.top >= this.computedOptions.minScrollable\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart-container.dc-scroll-bar-chart-container {\n  position: relative;\n  z-index: 0;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .axis,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler .axis {\n  display: none;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range {\n  z-index: 1;\n  position: relative;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .custom-brush-handle {\n  cursor: ew-resize;\n  stroke: black;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range g.brush {\n  fill: rgba(100, 100, 100, 0.1);\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range svg {\n  display: block;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler {\n  height: 12px;\n}\n</style>\n","<template>\n  <div class=\"dc-check-list-container\" :style=\"computedStyle\">\n    <slot name=\"search\">\n      <div class=\"dc-search-input-container\">\n        <label for=\".dc-search-input\" class=\"dc-search-input-label\">Search</label>\n        <input class=\"dc-search-input\" v-model=\"groupFilter\" @input=\"updateSearch\" />\n      </div>\n    </slot>\n    <div class=\"dc-checkbox-container\">\n      <div class=\"dc-checkbox\" v-for=\"item in shownGroups\" :key=\"item.key\" @click=\"toggleFilterFor(item.key)\">\n        <slot name=\"option\" v-bind:option=\"item\" v-bind:value=\"inFilter.includes(item.key)\">\n          <span class=\"dc-option-box\" :class=\"{ selected: inFilter.includes(item.key) }\" />\n          <span class=\"dc-option-label\" :class=\"{ selected: inFilter.includes(item.key) }\">\n            {{ item.key }} ({{ item.value | formatFilter(computedDigits) }})\n          </span>\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { flat, accessorFunc } from '../../dc-utils'\nexport default {\n  name: 'DcChecklist',\n  props: {\n    chart: {\n      type: [String, Object],\n      required: true\n    },\n    searchable: {\n      type: Boolean,\n      default: true\n    },\n    search: {\n      // if you want to override search string functionality\n      type: String,\n      default: ''\n    },\n    othersLimit: {\n      // define an \"others\" group cutoff. values past this number are considered in an \"others\" group\n      // not needed if options.slicesCap is defined\n      type: Number\n    },\n    digits: {\n      type: Number\n    },\n    maxHeight: {\n      // will make checkboxes scrollable with a max-height\n      type: [String, Number],\n      default: null\n    },\n    othersLabel: {\n      type: String\n    },\n    forceFilter: { // d => boolean to filter out empty/fake groups\n      type: Function,\n      default: null\n    }\n  },\n  data() {\n    return {\n      groupFilter: '',\n      groups: [],\n      others: [], // groups for pie charts which list an \"others\" category\n      inFilter: [],\n      waitInterval: null,\n      waitingTimer: 1\n    }\n  },\n  mounted() {\n    if (this.dcChart) {\n      this.reset()\n    } else {\n      this.waitForChartInit(true)\n    }\n  },\n  watch: {\n    dcChart(to, from) {\n      this.reset()\n    },\n    search() {\n      if (this.search != this.groupFilter) {\n        this.groupFilter = this.search\n      }\n    }\n  },\n  filters: {\n    formatFilter(value, digits) {\n      if (digits || digits === 0) {\n        return value.toFixed(digits)\n      } else {\n        return value\n      }\n    }\n  },\n  methods: {\n    reset() {\n      this.resetFilters()\n      this.updateListValues()\n      this.watchChartChanges()\n    },\n    resetFilters() {\n      // set the inFilter to match the chart\n      this.inFilter = Array.from(new Set(flat(this.dcChart.filters())))\n    },\n    updateListValues() {\n      // deep copy the groups so values do not get messed up when filtering\n      let groups = this.dcChart.group()\n        .order((value) => this.valueAccessor({ value }))\n        .top(Infinity)\n      if (this.forceFilter && typeof this.forceFilter === 'function') {\n        groups = groups.filter(this.forceFilter)\n      }\n      this.groups = JSON.parse(JSON.stringify(groups))\n      if (this.options.slicesCap || this.othersLimit) {\n        this.others = this.groups.slice(this.options.slicesCap || this.othersLimit).map((d) => d.key)\n      } else {\n        this.others = []\n      }\n    },\n    checkOthersFilterToggled() {\n      // fix issue where a category would get excluded by mistake when:\n      // - check a box in the 'others' category from this list\n      // - click the 'others' category on the pie chart after\n      // check for this case and add back in the category you clicked if necessary\n      let currentFilters = this.dcChart.filters()\n      let othersLabel = this.othersLabel || this.options.othersLabel || 'others'\n      const fixFilters = this.others.filter((k) => !currentFilters.includes(k) && this.inFilter.includes(k))\n      if (currentFilters.includes(othersLabel) && fixFilters.length) {\n        currentFilters.push(...fixFilters)\n        this.inFilter = currentFilters\n        this.dcChart.replaceFilter([currentFilters])\n      }\n    },\n    toggleFilterFor(key) {\n      if (this.inFilter.includes(key)) {\n        this.inFilter = this.inFilter.filter((k) => k !== key)\n      } else {\n        this.inFilter.push(key)\n      }\n\n      // yes this has to be an array of arrays thus [inFilter]\n      // https://stackoverflow.com/questions/38920359/how-to-filter-multiple-values-in-a-dc-crossfilter-dimension\n      // marked answer, first part mentions this\n      this.dcChart.replaceFilter([this.inFilter])\n      this.$nextTick(() => this.$dc.redrawAll())\n    },\n    updateSearch() {\n      this.$emit('update:search', this.groupFilter)\n      this.$emit('update-search', this.groupFilter)\n    },\n    watchChartChanges() {\n      // FIXME this prevents multiple checklists from listening to the same chart.\n      // is that okay?\n      this.dcChart.on('renderlet.checklist', () => {\n        this.updateListValues()\n      })\n      this.dcChart.on('filtered.checklist', () => {\n        this.$nextTick(() => {\n          this.checkOthersFilterToggled()\n          this.resetFilters()\n          this.updateListValues()\n        })\n      })\n    },\n    waitForChartInit(firstTry = false) {\n      this.waitInterval = setInterval(\n        () => {\n          this.waitingTimer = ((this.waitingTimer + 1) % 100) + 1\n          this.$nextTick(() => {\n            if (this.dcChart) {\n              this.reset()\n              clearInterval(this.waitInterval)\n              this.waitInterval = null\n            }\n          })\n        },\n        firstTry ? 50 : 300\n      )\n    }\n  },\n  computed: {\n    dcChart() {\n      // add waitingTimer (reactive) to the computed property as a dependency since this.$dc.chartRegistry.list() is not reactive\n      if (typeof this.chart === 'string' && this.waitingTimer) {\n        return this.$dc.chartRegistry.list().find((c) => c.name === this.chart)\n      } else {\n        return this.chart\n      }\n    },\n    shownGroups() {\n      if (!this.groupFilter || !this.groupFilter.length) {\n        return this.groups\n      } else {\n        return this.groups.filter((g) => {\n          const reg = new RegExp(this.groupFilter, 'gi')\n          return reg.test(g.key)\n        })\n      }\n    },\n    valueAccessor() {\n      return accessorFunc(this.options.valueAccessor || ((d) => d.value))\n    },\n    computedDigits() {\n      if (this.digits || this.digits === 0) {\n        return this.digits\n      } else {\n        return this.options.digits\n      }\n    },\n    computedStyle() {\n      let styles = []\n      if (this.maxHeight) {\n        styles.push('overflow-y: auto')\n        if (typeof this.maxHeight === 'number') {\n          styles.push(`max-height: ${this.maxHeight}px`)\n        } else {\n          styles.push(`max-height: ${this.maxHeight}`)\n        }\n      }\n\n      return styles.join('; ')\n    },\n    options() {\n      return this.dcChart?.vueOptions || {}\n    }\n  },\n  beforeDestroy() {\n    if (this.waitInterval) {\n      clearInterval(this.waitInterval)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-check-list-container {\n  text-align: left;\n  width: 100%;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input-label {\n  display: block;\n  font-weight: bold;\n  font-size: 0.85rem;\n  margin-bottom: -0.25rem;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input {\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n  width: calc(100% - 1.25rem);\n  border-color: black;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:nth-child(2n) {\n  background-color: whitesmoke;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box {\n  display: inline-block;\n  width: 1rem;\n  height: 1rem;\n  border-radius: 0.25rem;\n  margin: 0.25rem;\n  border: 2px solid black;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box.selected {\n  background-color: rgb(56, 140, 230, 1);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box {\n  background-color: rgba(56, 140, 230, 0.25);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box.selected {\n  background-color: rgba(56, 140, 230, 0.75);\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-composite-line-container\">\n    <div class=\"dc-chart dc-composite-line-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcCompositeLineChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: {\n      x: 50\n    }\n  },\n  props: {\n    /**\n     * {\n     *    name: string (will be displayed)\n     *    valueAccessor: string | ((d) => value)\n     *    color: string\n     * }\n     */\n    groups: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      groupCharts: []\n    }\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n\n      let { elastic, keyAccessor, renderArea } = this.computedOptions\n\n      this.chart = new this.$dc.CompositeChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      if (!this.computedAxisOptions.x?.x) {\n        let keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d.key))\n        let top = keyAccessor(this.$options.dimension.top(1)[0])\n        let bottom = keyAccessor(this.$options.dimension.bottom(1)[0])\n        this.chart.x(this.$d3.scaleLinear().domain([bottom, top]))\n      }\n\n      this.groupCharts = this.groups.map((chartGroup) => {\n        let groupChart = new this.$dc.LineChart(this.chart)\n          .group(group, chartGroup.name)\n          .valueAccessor(accessorFunc(chartGroup.valueAccessor || ((d) => d.value)))\n          .keyAccessor(accessorFunc(keyAccessor || ((d) => d.key)))\n        if (renderArea || chartGroup.renderArea) {\n          groupChart.renderArea(true)\n        }\n        if (chartGroup.color) {\n          groupChart.colors(chartGroup.color)\n        }\n        return groupChart\n      })\n\n      this.chart.compose(this.groupCharts)\n      this.applyLegendOptions()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.groupCharts)\n      this.$emit('create', this.chart, this.groupCharts)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-date-chart-container\">\n    <div class=\"dc-chart dc-date-chart\" :id=\"`chart-${_uid}`\" />\n  </div>\n</template>\n\n<script>\nimport { accessorFunc } from '../../dc-utils'\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin } from '../../mixins'\n\nexport default {\n  name: 'DcDateChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    renderArea: true,\n    limitTicksToNumDays: true, // limit the number of ticks to match the number of days under maxTicks\n    useD3TimeDay: true, // if passed no dimensionConstructor or string, will use d3.timeDay to construct dimension\n    snapDateCalculation: false,\n    useUtcSnapping: false,\n    fakeGroupingSettings: null // { startDate, endDate, fillValue }\n  },\n  methods: {\n    getDateBounds() {\n      const keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d?.date))\n\n      let top = new Date(keyAccessor(this.$options.dimension.top(1)[0]))\n      let bottom = new Date(keyAccessor(this.$options.dimension.bottom(1)[0]))\n\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        bottom = new Date(this.computedOptions.fakeGroupingSettings.startDate)\n        top = new Date(this.computedOptions.fakeGroupingSettings.endDate)\n      }\n\n      let { snapDateCalculation, useUtcSnapping } = this.computedOptions\n      if (snapDateCalculation) {\n        if (useUtcSnapping) {\n          top.setUTCHours(0, 0, 0, 0)\n          bottom.setUTCHours(23, 59, 59, 999)\n        } else {\n          top.setHours(0, 0, 0, 0)\n          bottom.setHours(23, 59, 59, 999)\n        }\n      }\n      // floor?\n      let days = Math.ceil(Math.abs(this.daysDifference(top, bottom)))\n      return { top, bottom, days }\n    },\n    daysDifference(d1, d2) {\n      if (!d1 || !d2 || !d1.getTime || !d2.getTime) {\n        return null\n      }\n      return (d2.getTime() - d1.getTime()) / 1000 / 60 / 60 / 24\n    },\n    createDimension() {\n      // override DimensionMixin to include d3.timeDay defaults for this chart\n      let { useD3TimeDay } = this.computedOptions\n      const timeDay = (d) => this.$d3.timeDay(new Date(d))\n\n      let dimensionAccessor = useD3TimeDay ? (d) => timeDay(this.$dc.pluck('date')(d)) : dc.pluck('date')\n\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = useD3TimeDay\n          ? (d) => timeDay(this.$dc.pluck(this.dimensionConstructor)(d))\n          : dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    },\n    // the user can specify a date range and fillValue to fill out any missing days from the data\n    // this will zero-out any missing days making the chart look more accurate!\n    fakeGroup (group, fakeGroupingSettings) {\n      let startDate = new Date(fakeGroupingSettings.startDate)\n      let endDate = new Date(fakeGroupingSettings.endDate)\n      const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))\n      return {\n        all() {\n          const original = group.all()\n          const originalDays = original.map(kv => kv.key.toISOString())\n          const result = []\n          const fillValue = fakeGroupingSettings.fillValue || {}\n          for (let i = 0; i <= days; i++) {\n            const thisDate = new Date(startDate)\n            thisDate.setDate(startDate.getDate() + i)\n\n            if (originalDays.includes(thisDate.toISOString())) {\n              continue // this date is already covered, we'll skip it\n            }\n            if (typeof fillValue === 'object') {\n              result.push(Object.assign({}, fillValue, { date: thisDate }))\n            } else  if (typeof fillValue === 'function') {\n              result.push(fillValue(thisDate))\n            }\n          }\n          // to draw the line left to right properly these MUST be sorted\n          return original.concat(result).sort((a, b) => a.key - b.key)\n        },\n        domain () {\n          return [startDate, endDate]\n        }\n      }\n    },\n    async createChart() {\n      let { elastic, renderArea } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let group = await this.createGroup(this.$options.dimension)\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        group = this.fakeGroup(group, this.computedOptions.fakeGroupingSettings)\n      }\n      let { top, bottom, days } = this.getDateBounds()\n\n      this.chart = new this.$dc.LineChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleTime().domain([bottom, top]))\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (renderArea) {\n        this.chart.renderArea(true)\n      }\n\n      if (this.computedOptions.limitTicksToNumDays) {\n        let maxTicks = this.computedAxisOptions.x?.ticks || 10\n        this.chart.xAxis().ticks(Math.min(maxTicks, days))\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <span class=\"dc-number-display\" :id=\"`chart-${_uid}`\"></span>\n</template>\n\n<script>\nimport { BaseChartMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils'\n\nexport default {\n  name: 'DcNumberDisplay',\n  mixins: [BaseChartMixin, GroupMixin],\n  methods: {\n    async createChart() {\n      const group = await this.createGroup(this.ndx, true)\n      this.chart = new this.$dc.NumberDisplay(`#chart-${this._uid}`).group(group)\n\n      this.chart.anchorName = () => {\n        return `#chart-${this._uid}`\n      }\n\n      this.$super(BaseChartMixin).createChart()\n\n      let { html, singular, plural, formatNumber, valueAccessor } = this.computedOptions\n\n      // resetting the value accessor whenever the data changes is required to recompute the unfilteredTotal\n      const makeValueAccessor = () => (d) => accessorFunc(valueAccessor || ((d) => d))(d, group.value())\n      this.ndx.onChange(type => {\n        if (type === 'dataAdded' || type === 'dataRemoved') {\n          this.chart.valueAccessor(makeValueAccessor())\n        }\n      })\n      this.chart.valueAccessor(makeValueAccessor())\n\n      if (html) {\n        this.chart.html(html)\n      } else if (singular) {\n        plural = plural || singular + 's'\n        this.chart.html({ one: `%number ${singular}`, some: `%number ${plural}`, none: `%number ${plural}` })\n      }\n\n      if (formatNumber) {\n        let format = typeof formatNumber === 'string' ? this.$d3.format(formatNumber) : formatNumber\n        this.chart.formatNumber(format)\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-pie-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { constrain } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcPieChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    minRadius: 0,\n    maxRadius: Infinity,\n    innerRadius: 0,\n    slicesCap: 10,\n    othersLabel: 'others',\n    useImprovedLabels: true,\n    labelWrapSeparator: ';|;' // if using improved labels you can separate key and value by this separator\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.chart = new this.$dc.PieChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group).externalRadiusPadding(12)\n      this.$super(BaseChartMixin).createChart()\n\n      let radius = this.getRadius()\n      this.chart.radius(radius)\n      this.chart.width(radius)\n      this.chart.height(radius)\n      let { innerRadius, slicesCap, othersLabel, useImprovedLabels } = this.computedOptions\n      if (slicesCap) {\n        this.chart.slicesCap(slicesCap)\n      }\n      if (othersLabel) {\n        this.chart.othersLabel(othersLabel)\n      }\n      if (innerRadius) {\n        // either exact number or 'X%' e.g. '50%'\n        let ir = typeof innerRadius === 'number' ? innerRadius : (radius * (parseInt(innerRadius) || 0)) / 100\n        this.chart.innerRadius(ir)\n      }\n\n      if (useImprovedLabels) {\n        const buildArc = () => {\n          const maxRadius = Math.min(this.chart.width(), this.chart.height()) / 1.8\n          const radius = Math.min(this.chart.radius(), maxRadius)\n          return this.$d3.arc().outerRadius(radius).innerRadius(this.chart.innerRadius())\n        }\n\n        const labelPosition = (d, arc) => {\n          const centroid = arc.centroid(d)\n          if (centroid.some((coord) => isNaN(coord))) {\n            return [0, 0]\n          } else {\n            return centroid\n          }\n        }\n\n        const wrap = (text) => {\n          // take text `key;|;value` and transform to `key` and `(value)` on two lines\n          const d3 = this.$d3\n          const labelWrapSeparator = this.computedOptions.labelWrapSeparator\n          text.each(function () {\n            const el = d3.select(this)\n            const words = el.text().split(labelWrapSeparator)\n            if (!words || words.length < 2) {\n              return // no need to wrap. not enough words\n            }\n\n            const tString = el.attr('transform')\n            const x = parseFloat(tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n            const y = parseFloat(tString.slice(tString.indexOf(',') + 1, tString.indexOf(')')))\n            if (Number.isNaN(x) || Number.isNaN(y)) {\n              console.warn('unable to wrap text', tString, x, y, tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n              return\n            }\n            let tspan = el.text(null).append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 0)\n            tspan.text(words[0])\n            tspan = el.append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 14)\n            tspan.text(`(${words[1].replace(/[^0-9\\-.]/g, '')})`)\n          })\n        }\n\n        const handleLabelTransition = () => {\n          this.chart.selectAll('text.pie-label').attr('transform', (d, i) => {\n            const arc = buildArc(this.chart)\n            const xy = labelPosition(d, arc)\n            let mult = (i + 1) / 6 + 0.3\n            if (xy[1] < 0) {\n              mult = 1\n            }\n            return `translate(${xy[0]}, ${xy[1] * mult})`\n          })\n          this.chart.selectAll('.pie-label-group text.pie-label').transition().call(wrap)\n        }\n\n        this.chart.on('renderlet.vue-dcjs', (chart) => {\n          const radius = this.getRadius()\n          if (this.chart.radius() !== radius) {\n            this.chart.radius(radius)\n            this.chart.height(radius)\n            this.chart.width(radius)\n            this.chart.redraw()\n          }\n        })\n        this.chart.on('pretransition.vue-dcjs', handleLabelTransition)\n      }\n    },\n    render() {\n        this.$super(BaseChartMixin).render()\n        if (this.computedOptions.useImprovedLabels) {\n          this.$nextTick(() => {\n            this.chart.redraw() // fix label position\n          })\n        }\n    },\n    getRadius() {\n      let container = document.querySelector(`#chart-${this._uid}`)\n      if (!container) {\n        return 0\n      }\n      let suggestedRadius = container.clientWidth\n      // in flex containers, this was returning 0 always\n      // look outside the dc-chart-container element to see the available space there\n      if (!suggestedRadius && container.parentNode && container.parentNode.parentNode) {\n        let paddingOffset = 0\n        let node = container.parentNode.parentNode\n        try {\n          const nodeStyle = window.getComputedStyle(node, null)\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-left')) || 0\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-right')) || 0\n        } catch {\n          paddingOffset = 0\n        }\n        suggestedRadius = node.clientWidth - paddingOffset\n      }\n      let { minRadius, maxRadius } = this.computedOptions\n      return constrain(suggestedRadius, minRadius, maxRadius)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-pie-chart .pie-slice:hover {\n  fill-opacity: 0.8;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-row-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-row-chart\" :class=\"{ 'is-scrollable': axisChart }\" :style=\"computedStyle\"></div>\n    <div v-show=\"canScroll\" :id=\"`chart-${_uid}-axis`\" class=\"dc-chart dc-axis-chart dc-row-axis-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcRowChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: true,\n    minHeight: 150,\n    barHeight: 20,\n    axisChartheight: 50,\n    scrollHeight: '200px',\n    scrollbarPadding: 0 // about the width of the scroll bar we are padding\n  },\n  data() {\n    return {\n      axisChart: null,\n      canScroll: false\n    }\n  },\n  methods: {\n    async createChart() {\n      // merge in default options\n      let { elastic, scrollable, minHeight, barHeight, axisChartHeight, valueAccessor, keyAccessor } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.canScroll = scrollable && group.size() * barHeight > minHeight\n\n      this.chart = new this.$dc.RowChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group)\n\n      this.$super(BaseChartMixin).createChart()\n      let rowChartMargin = this.canScroll ? Object.assign({}, this.computedMargins, { bottom: -1 }) : this.computedMargins\n      this.chart.margins(rowChartMargin)\n\n      if (elastic) {\n        this.chart.elasticX(true)\n      }\n\n      if (this.canScroll) {\n        this.chart.height(group.size() * barHeight)\n        this.chart.transitionDuration(1000)\n\n        let axisChartMargin = Object.assign({}, this.computedMargins, { top: 0 }) // enforce top margin\n        this.axisChart = new this.$dc.AxisChart(`#chart-${this._uid}-axis`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(axisChartHeight)\n          .margins(axisChartMargin)\n        if (valueAccessor) {\n          this.axisChart.valueAccessor(accessorFunc(valueAccessor))\n        }\n        if (keyAccessor) {\n          this.axisChart.keyAccessor(accessorFunc(keyAccessor))\n        }\n        if (elastic) {\n          this.axisChart.elastic(true)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      this.axisChart?.render()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.axisChart)\n      this.$emit('create', this.chart, this.axisChart)\n    }\n  },\n  computed: {\n    computedStyle() {\n      let styles = []\n      if (this.canScroll) {\n        styles.push('overflow-y: auto; overflow-x: hidden;')\n        if (this.computedOptions.scrollHeight) {\n          styles.push(`max-height: ${this.computedOptions.scrollHeight}`)\n        }\n      }\n      return styles.join('; ')\n    },\n    computedMargins() {\n      let margins = Object.assign(\n        { top: 30, right: 30, bottom: 30, left: 30 },\n        this.$options.defaultOptions?.margins,\n        this.options?.margins\n      )\n      const { scrollbarPadding } = this.computedOptions\n      if (this.canScroll && scrollbarPadding) {\n        margins.right += scrollbarPadding\n      }\n      return margins\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-row-chart.is-scrollable > svg {\n  position: relative;\n  top: 6px;\n}\n.dc-chart.dc-row-chart.is-scrollable .axis path,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick text,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick line:not(.grid-line) {\n  display: none !important;\n  stroke: none;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-stacked-bar-container\">\n    <div class=\"dc-chart dc-stacked-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc, constrain } from '../../dc-utils'\n\nexport default {\n  name: 'DcStackedBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: { x: 50 }\n  },\n  props: {\n    groups: {\n      // string[] left -> right x axis domain\n      type: Array,\n      required: true\n    },\n    stacks: {\n      // string[] | {name: string, color: string, key: string}[] bottom -> top group stack names for each key\n      type: Array,\n      required: true\n    },\n    colors: {\n      // string[], can also be provided in stacks.color (but only if every stack has provided a color value)\n      type: Array\n    },\n    keySeparator: {\n      type: String,\n      default: `;|;`\n    },\n    groupAccessor: {\n      type: [String, Function]\n    },\n    stackAccessor: {\n      type: [String, Function]\n    },\n    validateFunction: {\n      type: Function\n    }\n  },\n  methods: {\n    stackKey(stack) {\n      return typeof stack === 'string' ? stack : stack.key || stack.name || stack\n    },\n    stackName(stack) {\n      return typeof stack === 'string' ? stack : stack.name || stack.key || stack\n    },\n    computedValidateFunction(d, stack, group) {\n      if (this.validateFunction || this.computedOptions.validateFunction) {\n        let validate = this.validateFunction || this.computedOptions.validateFunction\n        return validate(d, stack, group)\n      } else {\n        const stackKey = this.stackKey(stack)\n        return this.stackAccessorFunc(d) === stackKey && this.groupAccessorFunc(d) === group\n      }\n    },\n    createChart() {\n      this.$options.dimension = this.ndx.dimension((d) => d)\n      let { add, remove, init } = this.stackReducer\n      const group = this.stackedGroup(this.$options.dimension.groupAll().reduce(add, remove, init))\n\n      const { elastic, title, barPadding, barGap, outerBarPadding } = this.computedOptions\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n      if (!this.computedAxisOptions.x?.x) {\n        this.chart.x(this.$d3.scaleBand().domain(this.groups))\n        this.chart.xUnits(this.$dc.units.ordinal)\n      }\n      let paddingDivisor = group.all().length || 1\n      this.chart.barPadding(constrain(2 / paddingDivisor, 0.1, 0.75))\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (this.computedColors.length) {\n        const colorScale = this.$d3\n          .scaleOrdinal()\n          .domain(this.stacks)\n          .range(this.stacks.map((stack, index) => this.computedColors[index % this.computedColors.length]))\n        this.chart.colors(colorScale)\n      }\n\n      function defaultTitleAccessor(d) {\n        return `${this.layer} ${d.key}: ${d.value[this.layer]}`\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      const keySeparator = this.keySeparator || ';|;'\n      const dc = this.$dc\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart\n          .selectAll('rect.bar')\n          .classed('deselected', false)\n          .classed('stack-deselected', function (d) {\n            // display stack faded if the chart has filters AND\n            // the current stack is not one of them\n            var groupKey = d.layer + keySeparator + d.x\n            return chart.filter() && !chart.filters().some((f) => f[0] === groupKey)\n          })\n          .on('click', function (evt, d) {\n            // filter this stack (default is whole row)\n            chart.filter([d.layer + keySeparator + d.x])\n            dc.redrawAll()\n          })\n      })\n\n      this.stacks.forEach((stack, index) => {\n        const groupKey = this.stackKey(stack)\n        const action = index ? 'stack' : 'group' // the first stack is just .group, the rest are .stack\n        // FIXME is there ever a reason to do this? can we use a different method for constructing/reducing the dimension and fake group after?\n        this.chart[action](group, groupKey, (d) => d.value[groupKey])\n      })\n\n      this.chart.legendables = () => {\n        const chart = this.chart\n        return this.stacks.map((stack) => {\n          const name = this.stackName(stack)\n          const groupKey = this.stackKey(stack)\n          const color = this.chart.colors()(groupKey)\n          return { chart, name, color }\n        })\n      }\n\n      this.applyLegendOptions()\n\n      this.chart.filterHandler((dimension, filters) => {\n        if (filters && filters.length) {\n          dimension.filterFunction((record) => {\n            return filters.some((c) => {\n              const [stack, groupKey] = c[0].split(this.keySeparator || ';|;')\n              // FIXME let user override this\n              return this.computedValidateFunction(record, stack, groupKey)\n            })\n          })\n        } else {\n          dimension.filter(null)\n        }\n        return filters\n      })\n    },\n    stackedGroup(group) {\n      let keySeparator = this.keySeparator\n      return {\n        all: function () {\n          var all = Object.entries(group.value()).map(([key, value]) => ({ key, value }))\n          var m = {}\n          all.forEach((kv) => {\n            const [k, s] = kv.key.split(keySeparator)\n            m[k] = m[k] || {}\n            m[k][s] = kv.value\n          })\n          return Object.keys(m).map((key) => {\n            return { key, value: m[key] }\n          })\n        }\n      }\n    }\n  },\n  computed: {\n    computedColors() {\n      let colors = this.colors || []\n      if (this.stacks && this.stacks.length && this.stacks.every((stack) => stack.color)) {\n        colors = this.stacks.map((stack) => stack.color)\n      }\n      if (!colors.length && this.stacks && this.stacks.length) {\n        colors = this.stacks.map((stack, index) => this.$d3.interpolateTurbo((index + 0.5) / this.stacks.length))\n      }\n      return colors\n    },\n    stackReducer() {\n      return {\n        add: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] +=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        remove: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] -=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        init: () => {\n          const p = {}\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              p[`${group}${this.keySeparator}${stackKey}`] = 0\n            })\n          })\n          return p\n        }\n      }\n    },\n    stackAccessorFunc() {\n      return accessorFunc(this.stackAccessor || this.computedOptions.stackAccessor || ((d) => d.stack))\n    },\n    groupAccessorFunc() {\n      return accessorFunc(this.groupAccessor || this.computedOptions.groupAccessor || ((d) => d.group))\n    }\n  }\n}\n</script>\n\n<style>\n.dc-stacked-bar-chart rect.bar.stack-deselected {\n  opacity: 0.2;\n}\n</style>\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install (Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport * from './mixins'\nexport { VueDc, dc, d3, crossfilter }\nexport default VueDc\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","calculateAxisScale","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","drawAxis","axisG","_g","select","empty","append","attr","transition","transitionDuration","transitionDelay","call","_doRender","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","axis","axisBottom","axisTop","axisRight","axisLeft","console","error","elastic","data","_doRedraw","constructor","parent","chartGroup","super","_defineProperty","_minHeight","_defaultHeightCalc","anchor","require","Object","assign","dc","renderAllNoTransitions","chartRegistry","list","forEach","chart","lastTransitionDuration","vueRender","render","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","_document$querySelect","_document$querySelect2","document","querySelector","closest","querySelectorAll","titleRoundDigits","dcConfig","DcPlugin","install","Vue","_options","options","setOptions","defaultColors","config","prototype","$dc","$d3","d3","$crossfilter","crossfilter","lastWidth","window","innerWidth","addEventListener","clearTimeout","setTimeout","script$c","props","axisOptions","autoTickHandler","methods","applyAxisOptions","_this$chart$xAxis","_this$chart","_this$chart$yAxis","_this$chart2","xAxisOptions","computedAxisOptions","x","yAxisOptions","y","xAxis","yAxis","applyTicks","ticks","applyFormat","format","tickFormat","applyValues","values","Array","isArray","tickValues","applySize","size","tickSize","tilt","classed","$options","dimension","autoTicks","ndx","onChange","evt","_this$chart3","_this$chart4","_group$top","_group$top$call","maxTicks","Math","max","valueAccessor","group","maxValue","ceil","min","computed","_this$computedOptions","_this$axisOptions","_this$computedOptions2","_this$axisOptions2","_this$computedOptions3","_this$axisOptions3","computedOptions","beforeDestroy","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","shadowRoot","originalRender","h","existing","beforeCreate","concat","isOldIE","navigator","test","userAgent","toLowerCase","id","css","media","styles","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","setAttribute","undefined","HEAD","head","getElementsByTagName","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","textNode","createTextNode","nodes","childNodes","removeChild","insertBefore","addStyle","accessorFunc","accessor","constrain","target","minValue","Infinity","name","myName","required","String","baseDefaultOptions","disposeDimension","resetButtonFunction","resetButtons","mounted","reset","[object Object]","createChart","addChartExtras","callOnCreate","onFilter","on","onClick","setupResetListener","renderChart","keyAccessor","title","label","height","width","digits","titleSuffix","titleDigits","_value","key","value","toFixed","computedMargins","onResetButtonClick","Promise","resolve","$emit","$nextTick","vueOptions","onCreate","charts","children","reduce","buttons","result","res","filterAll","redrawAll","button","updateButtonVisibility","hasFilter","some","instance","classList","remove","e","margin","right","bottom","_this$$options$defaul","_this$options","dim","deregister","dispose","dimensionConstructor","Function","dimensionIsArray","default","createDimension","dimensionAccessor","pluck","reducer","groupOptions","createGroup","groupAll","order","orderNatural","reduceSum","init","reject","resolveTimeout","replaceGroup","ordinalToLinear","valueFunc","isGroupAll","_ord2int","_int2ord","number","entries","sort","a","b","slice","all","ret","ord2int","o","int2ord","callback","num","legend","legendOptions","applyLegendOptions","showLegend","autoWidth","gap","highlightSelected","horizontal","itemHeight","itemWidth","keyboardAccessible","legendText","legendWidth","maxItems","computedLegendOptions","autoItemWidth","_this$defaultOptions","mixins","BaseChartMixin","DimensionMixin","GroupMixin","AxisMixin","scrollable","minScrollable","scrollHeight","mouseZoom","scaleChart","hasReplacedRenderFunc","_this$computedAxisOpt","filterFunction","barPadding","barGap","outerBarPadding","ordinalValueAccessor","v","linearDomain","defaultBarGap","_uid","clientWidth","BarChart","xUnits","units","integers","centerBar","brushOn","$super","kv","canScroll","elasticY","xAxisFormat","l","focusFilter","filterHandler","filters","f","every","includes","applyFilter","k","_listeners","_originalReplaceFilter","replaceFilter","fadeDeselectedArea","brushSelection","bars","chartBodyG","selectAll","constants","SELECTED_CLASS","DESELECTED_CLASS","splice","redrawGroup","floor","rescale","outerPadding","_invokeFilteredListener","filterType","rangeChart","zoomScale","mouseZoomable","_this$scaleChart","_preprocessData","_generateG","_generateClipPath","_drawChart","maxEnd","focus","searchable","search","othersLimit","Number","maxHeight","othersLabel","forceFilter","groupFilter","groups","others","inFilter","waitInterval","waitingTimer","dcChart","waitForChartInit","watch","to","from","formatFilter","resetFilters","updateListValues","watchChartChanges","array","acc","val","parse","slicesCap","checkOthersFilterToggled","currentFilters","fixFilters","toggleFilterFor","updateSearch","firstTry","setInterval","clearInterval","find","c","shownGroups","g","RegExp","computedDigits","computedStyle","_this$dcChart","LegendMixin","groupCharts","renderArea","CompositeChart","groupChart","LineChart","color","colors","compose","limitTicksToNumDays","useD3TimeDay","snapDateCalculation","useUtcSnapping","fakeGroupingSettings","getDateBounds","date","Date","startDate","endDate","setUTCHours","setHours","days","abs","daysDifference","d1","d2","getTime","timeDay","fakeGroup","original","originalDays","toISOString","fillValue","thisDate","setDate","getDate","scaleTime","NumberDisplay","anchorName","html","singular","plural","formatNumber","makeValueAccessor","one","none","minRadius","maxRadius","innerRadius","useImprovedLabels","labelWrapSeparator","PieChart","externalRadiusPadding","radius","getRadius","ir","parseInt","buildArc","arc","outerRadius","labelPosition","centroid","coord","isNaN","wrap","text","each","el","words","split","tString","parseFloat","warn","tspan","replace","handleLabelTransition","xy","mult","redraw","container","suggestedRadius","parentNode","paddingOffset","node","nodeStyle","getComputedStyle","getPropertyValue","minHeight","barHeight","axisChartheight","scrollbarPadding","axisChart","axisChartHeight","RowChart","rowChartMargin","elasticX","axisChartMargin","_this$axisChart","stacks","keySeparator","groupAccessor","stackAccessor","validateFunction","stackKey","stack","stackName","computedValidateFunction","stackAccessorFunc","groupAccessorFunc","stackReducer","stackedGroup","scaleBand","ordinal","paddingDivisor","computedColors","colorScale","scaleOrdinal","layer","groupKey","action","legendables","record","m","s","keys","interpolateTurbo","p","registerComponents","VueDc","Proxy","get","bind","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}