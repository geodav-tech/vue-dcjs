{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../src/mixins/axis.mixin.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../node_modules/vue-runtime-helpers/dist/inject-style/browser.mjs","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../src/mixins/dimension.mixin.vue","../src/mixins/group.mixin.vue","../src/mixins/legend.mixin.vue","../src/components/dc-bar-chart/dc-bar-chart.vue","../src/components/dc-checklist/dc-checklist.vue","../src/components/dc-composite-line-chart/dc-composite-line-chart.vue","../src/components/dc-date-chart/dc-date-chart.vue","../src/components/dc-number-display/dc-number-display.vue","../src/components/dc-pie-chart/dc-pie-chart.vue","../src/components/dc-row-chart/dc-row-chart.vue","../src/components/dc-stacked-bar-chart/dc-stacked-bar-chart.vue","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, axisLeft, axisRight, axisTop, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      const axis = { axisBottom, axisTop, axisRight, axisLeft }[type]\n      this._theAxis = axis()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this._minHeight = 0\n    this._defaultHeightCalc = () => 24\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\nconst renderAllNoTransitions = () => {\n  dc.chartRegistry.list().forEach(chart => {\n    // this will set the transition duration to 0 while we render\n    // this makes the resize less flashy/distracting\n    let lastTransitionDuration = chart.transitionDuration()\n    chart.transitionDuration(0)\n    if (chart.vueRender) { // if this is a vue-dc chart we can override with a custom render function to accomplish certain fixes\n      chart.vueRender()\n    } else {\n      chart.render()\n    }\n    // but then put the duration back to whatever it was before the render\n    chart.transitionDuration(lastTransitionDuration)\n  })\n}\n\n// assign extras via Object.assign to prevent module mutated warning\n// eslint-disable-next-line no-import-assign\nObject.assign(dc, { AxisChart,  renderAllNoTransitions })\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => {\n    return document.querySelector(chart.anchor())?.closest('.example-container')?.querySelectorAll('.example-reset-button') || []\n  },\n  titleRoundDigits: -1,\n}\n\nlet dcConfig = Object.assign({}, defaultOptions)\nconst setOptions = (options) => { dcConfig = options }\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    setOptions(options)\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      let lastWidth = window.innerWidth\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        if (lastWidth !== window.innerWidth) {\n          resizeTimeout = setTimeout(() => {\n            dc.renderAllNoTransitions()\n            resizeTimeout = null\n            lastWidth = window.innerWidth\n          }, options.resizeTimeout)\n        }\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter, dcConfig, setOptions }\n","<script>\nexport default {\n  name: 'AxisMixin',\n  props: {\n    /**\n     * x: AxisOptions,\n     * y: AxisOptions,\n     *\n     * AxisOptions: {\n     *  x: scale,\n     *  y: scale,\n     *  ticks: number,\n     *  format: string, number | d => value,\n     *  values: number[],\n     *  size: number\n     * }\n     */\n    axisOptions: {\n      // can also be in this.options\n      type: Object\n    }\n  },\n  data () {\n    return {\n      autoTickHandler: null\n    }\n  },\n  methods: {\n    applyAxisOptions() {\n      let xAxisOptions = this.computedAxisOptions.x\n      let yAxisOptions = this.computedAxisOptions.y\n      if (!this.chart || (!xAxisOptions && !yAxisOptions)) {\n        // nothing to apply to, or nothing to apply\n        return\n      }\n      const xAxis = this.chart.xAxis?.()\n      const yAxis = this.chart.yAxis?.()\n\n      const applyTicks = (axis, ticks) => {\n        if (ticks || ticks === 0) {\n          axis.ticks(ticks)\n        }\n      }\n\n      const applyFormat = (axis, format) => {\n        if (typeof format === 'string') {\n          axis.tickFormat(this.$d3.format(format))\n        } else if (typeof format === 'number') {\n          axis.tickFormat = this.$d3.format(`,.${format}f`)\n        } else if (typeof format === 'function') {\n          axis.tickFormat(format)\n        }\n      }\n\n      const applyValues = (axis, values) => {\n        if (values && Array.isArray(values)) {\n          axis.tickValues(values)\n        }\n      }\n\n      const applySize = (axis, size) => {\n        if (size || size === 0) {\n          axis.tickSize(size)\n        }\n      }\n\n      if (xAxisOptions && xAxis) {\n        applyTicks(xAxis, xAxisOptions.ticks)\n        applyFormat(xAxis, xAxisOptions.format)\n        applyValues(xAxis, xAxisOptions.values)\n        applySize(xAxis, xAxisOptions.size)\n        if (xAxisOptions.tilt) {\n          this.$d3.select(this.chart.anchor()).classed('tilted-x-axis', true)\n        }\n        if (xAxisOptions.x && typeof this.chart.x === 'function') {\n          this.chart.x(xAxisOptions.x(this.$options.dimension))\n        }\n      }\n\n      if (yAxisOptions && yAxis) {\n        applyTicks(yAxis, yAxisOptions.ticks)\n        applyFormat(yAxis, yAxisOptions.format)\n        applyValues(yAxis, yAxisOptions.values)\n        applySize(yAxis, yAxisOptions.size)\n        if (yAxisOptions.y && typeof this.chart.y === 'function') {\n          this.chart.y(yAxisOptions.y(this.$options.dimension))\n        }\n      }\n\n      if (yAxis && this.computedAxisOptions.autoTicks && this.ndx) {\n        this.ndx.onChange(evt => {\n          if (evt === 'filtered') {\n            const maxTicks = Math.max(yAxisOptions?.ticks || 0, 10)\n            const valueAccessor = this.chart?.valueAccessor()\n            const group = this.chart?.group()\n            const top = group?.top?.(1)?.[0]\n            let maxValue = maxTicks\n            try {\n              maxValue = Math.ceil(valueAccessor(top))\n            } catch {\n              maxValue = maxTicks\n            }\n            const ticks = Math.min(maxTicks, Math.max(1, maxValue))\n            yAxis.ticks(ticks)\n          }\n        })\n      }\n    }\n  },\n  computed: {\n    computedAxisOptions() {\n      return {\n        x: Object.assign({}, this.computedOptions?.xAxis, this.axisOptions?.x),\n        y:  Object.assign({}, this.computedOptions?.yAxis, this.axisOptions?.y),\n        autoTicks: this.computedOptions?.autoTicks || this.axisOptions?.autoTicks || false\n      }\n    }\n  },\n  beforeDestroy () {\n    if (this.autoTickHandler) {\n      this.autoTickHandler()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.tilted-x-axis .axis.x .tick text{\n  text-anchor: end;\n  transform: rotate(-33deg) translate(-4px, -2px);\n}\n\n</style>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","const isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nexport default createInjector;\n//# sourceMappingURL=browser.mjs.map\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc (accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain (target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat (array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nimport { dcConfig } from '../plugins/dc.plugin.js'\n\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    },\n    hasResetListener: {\n      type: Boolean,\n      default: true\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: []\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    async drawChart() {\n      // clear chart?\n      await this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (dcConfig.useResetListener && typeof dcConfig.resetSelector === 'function' && this.hasResetListener) {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width, digits, titleSuffix } = this.computedOptions\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = keyAccessor ? accessorFunc(keyAccessor)(d) : d.key\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins && this.chart.margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n\n      // allow our custom `renderAllNoTransitions` to call the overridden render func for vue-based charts\n      this.chart.vueRender = () => this.render()\n    },\n    onResetButtonClick() {},\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.computedOptions?.onCreate?.(this.chart)\n      this.$emit('create', this.chart)\n    },\n    setupResetListener() {\n      let charts = this.chart?.children ? [this.chart, ...this.chart.children()] : [this.chart]\n      try {\n        const { resetSelector } = dcConfig\n        this.resetButtons = charts.reduce((buttons, chart) => {\n          let result = resetSelector(chart)\n          if (typeof result.forEach !== 'function') {\n            buttons.push(result)\n          } else {\n            result.forEach((res) => {\n              buttons.push(res)\n            })\n          }\n          return buttons\n        }, [])\n\n        // ensure we can remove this later\n        this.resetButtonFunction = () => {\n          charts.forEach((chart) => {\n            chart.filterAll()\n          })\n          this.$dc.redrawAll()\n        }\n\n        this.resetButtons.forEach((button) => {\n          button.addEventListener('click', this.resetButtonFunction)\n        })\n        const updateButtonVisibility = () => {\n          let hasFilter = charts.some((chart) => chart.hasFilter())\n          this.resetButtons.forEach((instance) => {\n            if (hasFilter) {\n              instance.classList.remove('dc-reset-is-hidden')\n            } else {\n              instance.classList.add('dc-reset-is-hidden')\n            }\n          })\n        }\n\n        charts.forEach((chart) => {\n          chart.on('filtered.reset', updateButtonVisibility)\n        })\n        updateButtonVisibility() // update this on startup as well\n      } catch (e) {\n        console.error('Could not attach reset listener using resetSelector', e)\n      }\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","<script>\nexport default {\n  name: 'DimensionMixin',\n  props: {\n    dimensionConstructor: {\n      type: [String, Function] // (d) => value\n    },\n    dimensionIsArray: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    createDimension() {\n      let dimensionAccessor = (d) => d\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    }\n  }\n}\n</script>\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'GroupMixin',\n  props: {\n    reducer: {\n      type: [String, Function, Object]\n    },\n    groupOptions: {\n      /**\n       * order: d => orderValue,\n       * orderNatural: boolean (not compatable with order),\n       */\n      type: Object\n    }\n  },\n  methods: {\n    createGroup(dimension, groupAll = false) {\n      let group = groupAll ? dimension.groupAll() : dimension.group()\n\n      if (this.groupOptions && this.groupOptions.order) {\n        if (typeof this.groupOptions.order === 'string') {\n          group.order((d) => d[this.groupOptions.order])\n        } else if (typeof this.groupOptions.order === 'function') {\n          group.order(this.groupOptions.order)\n        }\n      } else if (this.groupOptions && this.groupOptions.orderNatural) {\n        group.orderNatural()\n      }\n\n      if (typeof this.reducer === 'string' || typeof this.reducer === 'function') {\n        group.reduceSum(accessorFunc(this.reducer))\n      } else if (this.reducer.add && this.reducer.remove && this.reducer.init) {\n        let { add, remove, init } = this.reducer\n        group.reduce(add, remove, init)\n      }\n      return new Promise((resolve, _reject) => {\n        let resolveTimeout = setTimeout(() => {\n          return resolve(group)\n        })\n        this.$emit('group-created', group, (replaceGroup) => {\n          // parent called back with a replacement\n          clearTimeout(resolveTimeout)\n          return resolve(replaceGroup)\n        })\n      })\n    },\n    // https://github.com/dc-js/dc.js/blob/develop/web-src/examples/focus-ordinal-bar.html\n    ordinalToLinear(group, valueFunc, isGroupAll = false) {\n      var _ord2int, _int2ord\n      return {\n        top: function (number = 1) {\n          if (isGroupAll) {\n            return Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n              .slice(0, number)\n          } else {\n            return group.order((d) => valueFunc(d)).top(number)\n          }\n        },\n        all: function () {\n          var ret = []\n          if (isGroupAll) {\n            ret = Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n          } else {\n            ret = group.order((d) => valueFunc(d)).top(Infinity)\n          }\n          _ord2int = {}\n          _int2ord = []\n          ret.forEach(function (d, i) {\n            _ord2int[d.key] = i\n            _int2ord[i] = d.key\n          })\n          return ret\n        },\n        ord2int: function (o) {\n          if (!_ord2int) {\n            this.all()\n          }\n          return _ord2int[o]\n        },\n        int2ord: function (i) {\n          if (!_int2ord) {\n            this.all()\n          }\n          return _int2ord[i]\n        },\n        order: function(callback) {\n          if (isGroupAll) {\n            // if this is a groupAll, we'll have to manually figure this out\n            // generally this is used for dc-checklist\n            const order = Object.entries(group.value()).map(([key, value]) => ({ key, value })).sort((a, b) => callback(b.value) - callback(a.value))\n            // since we just turned the return into an array, we have to fake some dc functions we expect to use on the array\n            // dc-checklist uses top, but we'll also add .all in case\n            order.top = (num) => order.slice(0, num)\n            order.all = () => order\n            return order\n          } else {\n            // if this isn't a groupAll, it has an order function and you can just use that\n            return group.order(callback)\n          }\n        }\n      }\n    }\n  }\n}\n</script>\n","<script>\nexport default {\n  name: 'LegendMixin',\n  props: {\n    legend: {\n      type: Boolean\n    },\n    legendOptions: {\n      type: Object\n    }\n  },\n  methods: {\n    applyLegendOptions() {\n      if (this.computedOptions.showLegend || this.computedOptions.legend || this.legend) {\n        let legend = this.$dc.legend()\n        let {\n          autoWidth,\n          gap,\n          highlightSelected,\n          horizontal,\n          itemHeight,\n          itemWidth,\n          keyboardAccessible,\n          legendText,\n          legendWidth,\n          maxItems,\n          x,\n          y\n        } = this.computedLegendOptions\n\n        // use !== undefined to allow false/0 values to be accepted\n\n        if (autoWidth !== undefined) {\n          legend.autoItemWidth(autoWidth)\n        } else if (itemWidth !== undefined) {\n          legend.itemWidth(itemWidth)\n        }\n\n        if (gap !== undefined) {\n          legend.gap(gap)\n        }\n\n        if (highlightSelected !== undefined) {\n          legend.highlightSelected(highlightSelected)\n        }\n\n        if (horizontal !== undefined) {\n          legend.horizontal(horizontal)\n        }\n        if (itemHeight !== undefined) {\n          legend.itemHeight(itemHeight)\n        }\n\n        if (keyboardAccessible !== undefined) {\n          legend.keyboardAccessible(keyboardAccessible)\n        }\n\n        if (legendText !== undefined) {\n          legend.legendText(legendText)\n        }\n        if (legendWidth !== undefined) {\n          legend.legendWidth(legendWidth)\n        }\n        if (maxItems !== undefined) {\n          legend.maxItems(maxItems)\n        }\n        if (x !== undefined) {\n          legend.x(x)\n        }\n        if (y !== undefined) {\n          legend.y(y)\n        }\n        this.chart.legend(legend)\n      }\n    }\n  },\n  computed: {\n    computedLegendOptions() {\n      return Object.assign({}, this.defaultOptions?.legendOptions, this.options?.legendOptions, this.legendOptions)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-scroll-bar-chart-container\">\n    <div v-if=\"computedOptions.scrollable\" style=\"position: relative; z-index: 0\">\n      <div class=\"dc-scroll-bar-range\" :class=\"{ hidden: !canScroll }\" :id=\"`chart-${_uid}-range`\"></div>\n      <!-- fill in the scroll-bar space if we cannot scroll -->\n      <div class=\"dc-scroll-bar-range-filler\" :class=\"{ hidden: canScroll }\"></div>\n    </div>\n    <div class=\"dc-chart dc-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { AxisMixin, BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\nimport { dcConfig } from '../../plugins/dc.plugin.js'\n\nexport default {\n  name: 'DcBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: false,\n    minScrollable: 12, // will not scroll if less than this number\n    scrollHeight: 12, // how tall the scroll chart is\n    mouseZoom: true\n  },\n  data() {\n    return {\n      scaleChart: null,\n      top: 0,\n      hasReplacedRenderFunc: false\n    }\n  },\n  methods: {\n    async createChart() {\n      this.hasReplacedRenderFunc = false\n      let {\n        elastic,\n        minScrollable,\n        scrollHeight,\n        groupAll,\n        valueAccessor,\n        title,\n        titleSuffix,\n        filterFunction,\n        mouseZoom,\n        barPadding,\n        barGap,\n        outerBarPadding,\n        digits\n      } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let ordinalValueAccessor = accessorFunc(valueAccessor || ((v) => v))\n      const group = this.ordinalToLinear(await this.createGroup(this.$options.dimension, groupAll), ordinalValueAccessor, groupAll)\n\n      this.top = group.all().length\n\n      const linearDomain = [-0.52, this.top - 0.5]\n      let defaultBarGap = this.top ? document.querySelector(`#chart-${this._uid}`).clientWidth / minScrollable / this.top : 0\n      defaultBarGap = Math.max(Math.ceil(defaultBarGap), 1)\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleLinear().domain(linearDomain))\n        .xUnits(this.$dc.units.integers)\n        .centerBar(true)\n        .brushOn(false)\n        .gap(defaultBarGap)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      this.chart.keyAccessor((kv) => group.ord2int(kv.key))\n      this.chart.valueAccessor((kv) => ordinalValueAccessor(kv.value))\n      this.chart.transitionDuration(this.canScroll ? 50 : 250)\n\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = d.key\n        // these require valueAccessor to pass d.value not d.... confusing\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d.value) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      let xAxisFormat = accessorFunc(this.computedAxisOptions.x?.format || (d => d))\n      this.chart.xAxis().tickFormat(d => xAxisFormat(group.int2ord(d))).ticks(this.top)\n      if (this.top <= minScrollable / 4) {\n        const l = this.top || 1\n        this.chart.barPadding(minScrollable / 2 / l)\n      }\n\n      let focusFilter = []\n      this.chart.filterHandler(function (_dimension, _filters) {}) // disable built in filtering\n\n      // overwrite with our own filtering logic\n      this.chart.hasFilter = function (f) {\n        if (Array.isArray(f)) {\n          return f.every((filter) => focusFilter.includes(filter))\n        } else if (f) {\n          return focusFilter.includes(f)\n        } else {\n          return focusFilter.length\n        }\n      }\n\n      this.chart.applyFilter = function () {\n        if (focusFilter.length) {\n          this.dimension().filterFunction(function (k) {\n            if (filterFunction) {\n              return filterFunction(focusFilter, k)\n            } else {\n              return focusFilter.includes(k)\n            }\n          })\n        } else {\n          this.dimension().filter(null)\n        }\n        // hook this custom filter logic back into the on('filtered') event handler\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this._listeners.call('filtered', this, this, focusFilter)\n      }\n\n      this.chart.filterAll = function () {\n        focusFilter = []\n        this.applyFilter()\n      }\n\n      // .filters now provides the actual keys as filters (dc-checklist support)\n      this.chart.filters = () => [...focusFilter]\n\n      // keep the original replaceFilter function for zoom settings\n      this.chart._originalReplaceFilter = this.chart.replaceFilter\n      this.chart.replaceFilter = function (filters) {\n        // replaceFilter can be called by the dc-checklist\n        // if everything is an array, it's a real request to replace filters the way we would expect\n        if (filters.every(filter => Array.isArray(filter))) {\n          focusFilter = []\n          // filters should look something like [['management', 'team2']] (double array)\n          filters.forEach(filter => {\n            // push inner array elements to the focus filter\n            focusFilter.push(...filter)\n          })\n          this.applyFilter() // apply the focus filter\n          return this // return the chart\n        } else {\n          // if this is not an array, then this is really a request to change the scroll area\n          return this._originalReplaceFilter(filters)\n        }\n      }\n\n      const dc = this.$dc\n      const d3 = this.$d3\n      this.chart.fadeDeselectedArea = function (_brushSelection) {\n        let bars = this.chartBodyG().selectAll('rect.bar')\n        if (focusFilter.length) {\n          bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n            return focusFilter.includes(d.data.key)\n          })\n          bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n            return !focusFilter.includes(d.data.key)\n          })\n        } else {\n          bars.classed(dc.constants.SELECTED_CLASS, false)\n          bars.classed(dc.constants.DESELECTED_CLASS, false)\n        }\n      }\n\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart.selectAll('rect.bar').on('click.ordinal-select', function (e, d) {\n          var i = focusFilter.indexOf(d.data.key)\n          if (i >= 0) {\n            focusFilter.splice(i, 1)\n          } else {\n            focusFilter.push(d.data.key)\n          }\n          chart.applyFilter()\n          chart.redrawGroup()\n        })\n      })\n\n      this.chart.on('preRedraw.vue-dcjs', function (chart) {\n        const domain = chart.x().domain()\n        const min = Math.ceil(domain[0])\n        const max = Math.floor(domain[1])\n        chart.xAxis().tickValues(d3.range(min, max + 1))\n        chart.rescale() // allow x axis to match ordering changes\n      })\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      // FIXME text wrapping x axis in shared thing?\n\n      if (this.canScroll) {\n        let { top, bottom, left, right } = this.computedMargins\n        this.chart.margins({ top: 0, bottom, left, right })\n\n        // do not send focus events as filter events to anyone listening to this.chart.on('filtered')\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this.chart._invokeFilteredListener = function (f) {\n          // ignore 'RangedFilter' type. it's coming from the scale chart as long as brushing is disabled\n          if (f !== undefined && f.filterType !== 'RangedFilter') {\n            return this._listeners.call('filtered', this, this, f)\n          }\n        }\n\n        this.scaleChart = new this.$dc.BarChart(`#chart-${this._uid}-range`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(scrollHeight + top)\n          .margins({ left, top, right, bottom: 2 })\n          .x(this.$d3.scaleLinear().domain(linearDomain))\n          .xUnits(this.$dc.units.integers)\n          .keyAccessor((kv) => group.ord2int(kv.key))\n          .centerBar(true)\n          .valueAccessor((kv) => ordinalValueAccessor(kv.value))\n          .brushOn(true)\n          .transitionDuration(0)\n          .gap(1)\n\n        this.scaleChart.filterHandler(function () {}) // ensure the scale chart has no filterFunction (it will mess up scaling on all charts)\n        this.scaleChart.yAxis().ticks(0)\n        this.scaleChart.xAxis().ticks(0)\n\n        this.chart.rangeChart(this.scaleChart)\n        this.chart.zoomScale([Math.min(8, Math.ceil(this.top / 12)), Math.min(this.top, 12)])\n        if (elastic) {\n          this.scaleChart.elasticY(true)\n        }\n        if (mouseZoom) {\n          this.chart.mouseZoomable(this.canScroll)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      if (this.canScroll) {\n        if (!this.hasReplacedRenderFunc) {\n          // Calling `dc.renderAll()` messed up mouse zooming with this chart\n          // so this fixes things when using the window resize handler which calls dc.renderAll() to resize the charts\n          // rewriting this function without `this._configureMouseZoom()` seems to work?\n          // http://dc-js.github.io/dc.js/docs/html/base_coordinate-grid-mixin.js.html#sunlight-1-line-1150\n          // https://github.com/dc-js/dc.js/issues/1857\n          this.chart._doRender = function () {\n            this.resetSvg()\n            this._preprocessData()\n            this._generateG()\n            this._generateClipPath()\n            this._drawChart(true)\n            return this\n          }\n          this.hasReplacedRenderFunc = true\n        }\n        this.scaleChart?.render()\n        const maxEnd = Math.min(12, Math.floor(this.top / Math.min(8, Math.ceil(this.top / 12))))\n        this.chart.focus([-1, maxEnd])\n      }\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.scaleChart)\n      this.$emit('create', this.chart, this.scaleChart)\n    }\n  },\n  computed: {\n    canScroll() {\n      return this.computedOptions.scrollable && this.top >= this.computedOptions.minScrollable\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart-container.dc-scroll-bar-chart-container {\n  position: relative;\n  z-index: 0;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .axis,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler .axis {\n  display: none;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range {\n  z-index: 1;\n  position: relative;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .custom-brush-handle {\n  cursor: ew-resize;\n  stroke: black;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range g.brush {\n  fill: rgba(100, 100, 100, 0.1);\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range svg {\n  display: block;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler {\n  height: 12px;\n}\n</style>\n","<template>\n  <div class=\"dc-check-list-container\" :style=\"computedStyle\">\n    <slot name=\"search\">\n      <div class=\"dc-search-input-container\">\n        <label for=\".dc-search-input\" class=\"dc-search-input-label\">Search</label>\n        <input class=\"dc-search-input\" v-model=\"groupFilter\" @input=\"updateSearch\" />\n      </div>\n    </slot>\n    <div class=\"dc-checkbox-container\">\n      <div class=\"dc-checkbox\" v-for=\"item in shownGroups\" :key=\"item.key\" @click=\"toggleFilterFor(item.key)\">\n        <slot name=\"option\" v-bind:option=\"item\" v-bind:value=\"inFilter.includes(item.key)\">\n          <span class=\"dc-option-box\" :class=\"{ selected: inFilter.includes(item.key) }\" />\n          <span class=\"dc-option-label\" :class=\"{ selected: inFilter.includes(item.key) }\">\n            {{ displayKey(item) }} ({{ item.value | formatFilter(computedDigits) }})\n          </span>\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { flat, accessorFunc } from '../../dc-utils'\nexport default {\n  name: 'DcChecklist',\n  props: {\n    chart: {\n      type: [String, Object],\n      required: true\n    },\n    searchable: {\n      type: Boolean,\n      default: true\n    },\n    search: {\n      // if you want to override search string functionality\n      type: String,\n      default: ''\n    },\n    othersLimit: {\n      // define an \"others\" group cutoff. values past this number are considered in an \"others\" group\n      // not needed if options.slicesCap is defined\n      type: Number\n    },\n    digits: {\n      type: Number\n    },\n    maxHeight: {\n      // will make checkboxes scrollable with a max-height\n      type: [String, Number],\n      default: null\n    },\n    othersLabel: {\n      type: String\n    },\n    forceFilter: { // d => boolean to filter out empty/fake groups\n      type: Function,\n      default: null\n    },\n    keyDisplay: { // d => string to display and search key\n      type: Function,\n      default: null\n    }\n  },\n  data() {\n    return {\n      groupFilter: '',\n      groups: [],\n      others: [], // groups for pie charts which list an \"others\" category\n      inFilter: [],\n      waitInterval: null,\n      waitingTimer: 1\n    }\n  },\n  mounted() {\n    if (this.dcChart) {\n      this.reset()\n    } else {\n      this.waitForChartInit(true)\n    }\n  },\n  watch: {\n    dcChart(_to, _from) {\n      this.reset()\n    },\n    search() {\n      if (this.search != this.groupFilter) {\n        this.groupFilter = this.search\n      }\n    }\n  },\n  filters: {\n    formatFilter(value, digits) {\n      if (digits || digits === 0) {\n        return value.toFixed(digits)\n      } else {\n        return value\n      }\n    }\n  },\n  methods: {\n    reset() {\n      this.resetFilters()\n      this.updateListValues()\n      this.watchChartChanges()\n    },\n    resetFilters() {\n      // set the inFilter to match the chart\n      this.inFilter = Array.from(new Set(flat(this.dcChart.filters())))\n    },\n    updateListValues() {\n      // deep copy the groups so values do not get messed up when filtering\n      let groups = this.dcChart.group()\n        .order((value) => this.valueAccessor({ value }))\n        .top(Infinity)\n      if (this.forceFilter && typeof this.forceFilter === 'function') {\n        groups = groups.filter(this.forceFilter)\n      }\n      this.groups = JSON.parse(JSON.stringify(groups))\n      if (this.options.slicesCap || this.othersLimit) {\n        this.others = this.groups.slice(this.options.slicesCap || this.othersLimit).map((d) => d.key)\n      } else {\n        this.others = []\n      }\n    },\n    checkOthersFilterToggled() {\n      // fix issue where a category would get excluded by mistake when:\n      // - check a box in the 'others' category from this list\n      // - click the 'others' category on the pie chart after\n      // check for this case and add back in the category you clicked if necessary\n      let currentFilters = this.dcChart.filters()\n      let othersLabel = this.othersLabel || this.options.othersLabel || 'others'\n      const fixFilters = this.others.filter((k) => !currentFilters.includes(k) && this.inFilter.includes(k))\n      if (currentFilters.includes(othersLabel) && fixFilters.length) {\n        currentFilters.push(...fixFilters)\n        this.inFilter = currentFilters\n        this.dcChart.replaceFilter([currentFilters])\n      }\n    },\n    toggleFilterFor(key) {\n      if (this.inFilter.includes(key)) {\n        this.inFilter = this.inFilter.filter((k) => k !== key)\n      } else {\n        this.inFilter.push(key)\n      }\n\n      // yes this has to be an array of arrays thus [inFilter]\n      // https://stackoverflow.com/questions/38920359/how-to-filter-multiple-values-in-a-dc-crossfilter-dimension\n      // marked answer, first part mentions this\n      this.dcChart.replaceFilter([this.inFilter])\n      this.$nextTick(() => this.$dc.redrawAll())\n    },\n    updateSearch() {\n      this.$emit('update:search', this.groupFilter)\n      this.$emit('update-search', this.groupFilter)\n    },\n    watchChartChanges() {\n      this.dcChart.on(`renderlet.checklist_${this._uid}`, () => {\n        this.updateListValues()\n      })\n      this.dcChart.on(`filtered.checklist_${this._uid}`, () => {\n        this.$nextTick(() => {\n          this.checkOthersFilterToggled()\n          this.resetFilters()\n          this.updateListValues()\n        })\n      })\n    },\n    waitForChartInit(firstTry = false) {\n      this.waitInterval = setInterval(\n        () => {\n          this.waitingTimer = ((this.waitingTimer + 1) % 100) + 1\n          this.$nextTick(() => {\n            if (this.dcChart) {\n              this.reset()\n              clearInterval(this.waitInterval)\n              this.waitInterval = null\n            }\n          })\n        },\n        firstTry ? 50 : 300\n      )\n    }\n  },\n  computed: {\n    dcChart() {\n      // add waitingTimer (reactive) to the computed property as a dependency since this.$dc.chartRegistry.list() is not reactive\n      if (typeof this.chart === 'string' && this.waitingTimer) {\n        return this.$dc.chartRegistry.list().find((c) => c.name === this.chart)\n      } else {\n        return this.chart\n      }\n    },\n    displayKey () {\n      return (option) => {\n        return this.keyDisplay ? this.keyDisplay(option) : option?.key || ''\n      }\n    },\n    shownGroups() {\n      if (!this.groupFilter || !this.groupFilter.length) {\n        return this.groups\n      } else {\n        return this.groups.filter((g) => {\n          const reg = new RegExp(this.groupFilter, 'gi')\n          return reg.test(this.displayKey(g))\n        })\n      }\n    },\n    valueAccessor() {\n      return accessorFunc(this.options.valueAccessor || ((d) => d.value))\n    },\n    computedDigits() {\n      if (this.digits || this.digits === 0) {\n        return this.digits\n      } else {\n        return this.options.digits\n      }\n    },\n    computedStyle() {\n      let styles = []\n      if (this.maxHeight) {\n        styles.push('overflow-y: auto')\n        if (typeof this.maxHeight === 'number') {\n          styles.push(`max-height: ${this.maxHeight}px`)\n        } else {\n          styles.push(`max-height: ${this.maxHeight}`)\n        }\n      }\n\n      return styles.join('; ')\n    },\n    options() {\n      return this.dcChart?.vueOptions || {}\n    }\n  },\n  beforeDestroy() {\n    if (this.waitInterval) {\n      clearInterval(this.waitInterval)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-check-list-container {\n  text-align: left;\n  width: 100%;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input-label {\n  display: block;\n  font-weight: bold;\n  font-size: 0.85rem;\n  margin-bottom: -0.25rem;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input {\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n  width: calc(100% - 1.25rem);\n  border-color: black;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:nth-child(2n) {\n  background-color: whitesmoke;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box {\n  display: inline-block;\n  width: 1rem;\n  height: 1rem;\n  border-radius: 0.25rem;\n  margin: 0.25rem;\n  border: 2px solid black;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box.selected {\n  background-color: rgb(56, 140, 230, 1);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box {\n  background-color: rgba(56, 140, 230, 0.25);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box.selected {\n  background-color: rgba(56, 140, 230, 0.75);\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-composite-line-container\">\n    <div class=\"dc-chart dc-composite-line-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcCompositeLineChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: {\n      x: 50\n    }\n  },\n  props: {\n    /**\n     * {\n     *    name: string (will be displayed)\n     *    valueAccessor: string | ((d) => value)\n     *    color: string\n     * }\n     */\n    groups: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      groupCharts: []\n    }\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n\n      let { elastic, keyAccessor, renderArea } = this.computedOptions\n\n      this.chart = new this.$dc.CompositeChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      if (!this.computedAxisOptions.x?.x) {\n        let keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d.key))\n        let top = keyAccessor(this.$options.dimension.top(1)[0])\n        let bottom = keyAccessor(this.$options.dimension.bottom(1)[0])\n        this.chart.x(this.$d3.scaleLinear().domain([bottom, top]))\n      }\n\n      this.groupCharts = this.groups.map((chartGroup) => {\n        let groupChart = new this.$dc.LineChart(this.chart)\n          .group(group, chartGroup.name)\n          .valueAccessor(accessorFunc(chartGroup.valueAccessor || ((d) => d.value)))\n          .keyAccessor(accessorFunc(keyAccessor || ((d) => d.key)))\n        if (renderArea || chartGroup.renderArea) {\n          groupChart.renderArea(true)\n        }\n        if (chartGroup.color) {\n          groupChart.colors(chartGroup.color)\n        }\n        return groupChart\n      })\n\n      this.chart.compose(this.groupCharts)\n      this.applyLegendOptions()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.groupCharts)\n      this.$emit('create', this.chart, this.groupCharts)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-date-chart-container\">\n    <div class=\"dc-chart dc-date-chart\" :id=\"`chart-${_uid}`\" />\n  </div>\n</template>\n\n<script>\nimport { accessorFunc } from '../../dc-utils'\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin } from '../../mixins'\n\nexport default {\n  name: 'DcDateChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    renderArea: true,\n    limitTicksToNumDays: true, // limit the number of ticks to match the number of days under maxTicks\n    useD3TimeDay: true, // if passed no dimensionConstructor or string, will use d3.timeDay to construct dimension\n    snapDateCalculation: false,\n    useUtcSnapping: false,\n    fakeGroupingSettings: null // { startDate, endDate, fillValue }\n  },\n  methods: {\n    getDateBounds() {\n      const keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d?.date))\n\n      let top = new Date(keyAccessor(this.$options.dimension.top(1)[0]))\n      let bottom = new Date(keyAccessor(this.$options.dimension.bottom(1)[0]))\n\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        bottom = new Date(this.computedOptions.fakeGroupingSettings.startDate)\n        top = new Date(this.computedOptions.fakeGroupingSettings.endDate)\n      }\n\n      let { snapDateCalculation, useUtcSnapping } = this.computedOptions\n      if (snapDateCalculation) {\n        if (useUtcSnapping) {\n          top.setUTCHours(0, 0, 0, 0)\n          bottom.setUTCHours(23, 59, 59, 999)\n        } else {\n          top.setHours(0, 0, 0, 0)\n          bottom.setHours(23, 59, 59, 999)\n        }\n      }\n      // floor?\n      let days = Math.ceil(Math.abs(this.daysDifference(top, bottom)))\n      return { top, bottom, days }\n    },\n    daysDifference(d1, d2) {\n      if (!d1 || !d2 || !d1.getTime || !d2.getTime) {\n        return null\n      }\n      return (d2.getTime() - d1.getTime()) / 1000 / 60 / 60 / 24\n    },\n    createDimension() {\n      // override DimensionMixin to include d3.timeDay defaults for this chart\n      let { useD3TimeDay } = this.computedOptions\n      const timeDay = (d) => this.$d3.timeDay(new Date(d))\n\n      let dimensionAccessor = useD3TimeDay ? (d) => timeDay(this.$dc.pluck('date')(d)) : this.$dc.pluck('date')\n\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = useD3TimeDay\n          ? (d) => timeDay(this.$dc.pluck(this.dimensionConstructor)(d))\n          : this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    },\n    // the user can specify a date range and fillValue to fill out any missing days from the data\n    // this will zero-out any missing days making the chart look more accurate!\n    fakeGroup (group, fakeGroupingSettings) {\n      let startDate = new Date(fakeGroupingSettings.startDate)\n      let endDate = new Date(fakeGroupingSettings.endDate)\n      const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))\n      return {\n        all() {\n          const original = group.all()\n          const originalDays = original.map(kv => kv.key.toISOString())\n          const result = []\n          const fillValue = fakeGroupingSettings.fillValue || {}\n          for (let i = 0; i <= days; i++) {\n            const thisDate = new Date(startDate)\n            thisDate.setDate(startDate.getDate() + i)\n\n            if (originalDays.includes(thisDate.toISOString())) {\n              continue // this date is already covered, we'll skip it\n            }\n            if (typeof fillValue === 'object') {\n              result.push(Object.assign({}, fillValue, { date: thisDate }))\n            } else  if (typeof fillValue === 'function') {\n              result.push(fillValue(thisDate))\n            }\n          }\n          // to draw the line left to right properly these MUST be sorted\n          return original.concat(result).sort((a, b) => a.key - b.key)\n        },\n        domain () {\n          return [startDate, endDate]\n        }\n      }\n    },\n    async createChart() {\n      let { elastic, renderArea } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let group = await this.createGroup(this.$options.dimension)\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        group = this.fakeGroup(group, this.computedOptions.fakeGroupingSettings)\n      }\n      let { top, bottom, days } = this.getDateBounds()\n\n      this.chart = new this.$dc.LineChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleTime().domain([bottom, top]))\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (renderArea) {\n        this.chart.renderArea(true)\n      }\n\n      if (this.computedOptions.limitTicksToNumDays) {\n        let maxTicks = this.computedAxisOptions.x?.ticks || 10\n        this.chart.xAxis().ticks(Math.min(maxTicks, days))\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <span class=\"dc-number-display\" :id=\"`chart-${_uid}`\"></span>\n</template>\n\n<script>\nimport { BaseChartMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils'\n\nexport default {\n  name: 'DcNumberDisplay',\n  mixins: [BaseChartMixin, GroupMixin],\n  props: {\n    // number displays don't have filters, so we don't need reset listeners\n    hasResetListener: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    async createChart() {\n      const group = await this.createGroup(this.ndx, true)\n      this.chart = new this.$dc.NumberDisplay(`#chart-${this._uid}`).group(group)\n\n      this.chart.anchorName = () => {\n        return `#chart-${this._uid}`\n      }\n\n      this.$super(BaseChartMixin).createChart()\n\n      let { html, singular, plural, formatNumber, valueAccessor } = this.computedOptions\n\n      // resetting the value accessor whenever the data changes is required to recompute the unfilteredTotal\n      const makeValueAccessor = () => (d) => accessorFunc(valueAccessor || ((d) => d))(d, group.value())\n      this.ndx.onChange(type => {\n        if (type === 'dataAdded' || type === 'dataRemoved') {\n          this.chart.valueAccessor(makeValueAccessor())\n        }\n      })\n      this.chart.valueAccessor(makeValueAccessor())\n\n      if (html) {\n        this.chart.html(html)\n      } else if (singular) {\n        plural = plural || singular + 's'\n        this.chart.html({ one: `%number ${singular}`, some: `%number ${plural}`, none: `%number ${plural}` })\n      }\n\n      if (formatNumber) {\n        let format = typeof formatNumber === 'string' ? this.$d3.format(formatNumber) : formatNumber\n        this.chart.formatNumber(format)\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-pie-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { constrain } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcPieChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    minRadius: 0,\n    maxRadius: Infinity,\n    innerRadius: 0,\n    slicesCap: 10,\n    othersLabel: 'others',\n    useImprovedLabels: true,\n    labelWrapSeparator: ';|;' // if using improved labels you can separate key and value by this separator\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.chart = new this.$dc.PieChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group).externalRadiusPadding(12)\n      this.$super(BaseChartMixin).createChart()\n\n      let radius = this.getRadius()\n      this.chart.radius(radius)\n      this.chart.width(radius)\n      this.chart.height(radius)\n      let { innerRadius, slicesCap, othersLabel, useImprovedLabels } = this.computedOptions\n      if (slicesCap) {\n        this.chart.slicesCap(slicesCap)\n      }\n      if (othersLabel) {\n        this.chart.othersLabel(othersLabel)\n      }\n      if (innerRadius) {\n        // either exact number or 'X%' e.g. '50%'\n        let ir = typeof innerRadius === 'number' ? innerRadius : (radius * (parseInt(innerRadius) || 0)) / 100\n        this.chart.innerRadius(ir)\n      }\n\n      if (useImprovedLabels) {\n        const buildArc = () => {\n          const maxRadius = Math.min(this.chart.width(), this.chart.height()) / 1.8\n          const radius = Math.min(this.chart.radius(), maxRadius)\n          return this.$d3.arc().outerRadius(radius).innerRadius(this.chart.innerRadius())\n        }\n\n        const labelPosition = (d, arc) => {\n          const centroid = arc.centroid(d)\n          if (centroid.some((coord) => isNaN(coord))) {\n            return [0, 0]\n          } else {\n            return centroid\n          }\n        }\n\n        const wrap = (text) => {\n          // take text `key;|;value` and transform to `key` and `(value)` on two lines\n          const d3 = this.$d3\n          const labelWrapSeparator = this.computedOptions.labelWrapSeparator\n          text.each(function () {\n            const el = d3.select(this)\n            const words = el.text().split(labelWrapSeparator)\n            if (!words || words.length < 2) {\n              return // no need to wrap. not enough words\n            }\n\n            const tString = el.attr('transform')\n            const x = parseFloat(tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n            const y = parseFloat(tString.slice(tString.indexOf(',') + 1, tString.indexOf(')')))\n            if (Number.isNaN(x) || Number.isNaN(y)) {\n              console.warn('unable to wrap text', tString, x, y, tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n              return\n            }\n            let tspan = el.text(null).append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 0)\n            tspan.text(words[0])\n            tspan = el.append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 14)\n            tspan.text(`(${words[1].replace(/[^0-9\\-.]/g, '')})`)\n          })\n        }\n\n        const handleLabelTransition = () => {\n          this.chart.selectAll('text.pie-label').attr('transform', (d, i) => {\n            const arc = buildArc(this.chart)\n            const xy = labelPosition(d, arc)\n            let mult = (i + 1) / 6 + 0.3\n            if (xy[1] < 0) {\n              mult = 1\n            }\n            return `translate(${xy[0]}, ${xy[1] * mult})`\n          })\n          this.chart.selectAll('.pie-label-group text.pie-label').transition().call(wrap)\n        }\n\n        this.chart.on('renderlet.vue-dcjs', (_chart) => {\n          const radius = this.getRadius()\n          if (this.chart.radius() !== radius) {\n            this.chart.radius(radius)\n            this.chart.height(radius)\n            this.chart.width(radius)\n            this.chart.redraw()\n          }\n        })\n        this.chart.on('pretransition.vue-dcjs', handleLabelTransition)\n      }\n    },\n    render() {\n        this.$super(BaseChartMixin).render()\n        if (this.computedOptions.useImprovedLabels) {\n          this.$nextTick(() => {\n            this.chart.redraw() // fix label position\n          })\n        }\n    },\n    getRadius() {\n      let container = document.querySelector(`#chart-${this._uid}`)\n      if (!container) {\n        return 0\n      }\n      let suggestedRadius = container.clientWidth\n      // in flex containers, this was returning 0 always\n      // look outside the dc-chart-container element to see the available space there\n      if (!suggestedRadius && container.parentNode && container.parentNode.parentNode) {\n        let paddingOffset = 0\n        let node = container.parentNode.parentNode\n        try {\n          const nodeStyle = window.getComputedStyle(node, null)\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-left')) || 0\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-right')) || 0\n        } catch {\n          paddingOffset = 0\n        }\n        suggestedRadius = node.clientWidth - paddingOffset\n      }\n      let { minRadius, maxRadius } = this.computedOptions\n      return constrain(suggestedRadius, minRadius, maxRadius)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-pie-chart .pie-slice:hover {\n  fill-opacity: 0.8;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-row-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-row-chart\" :class=\"{ 'is-scrollable': axisChart }\" :style=\"computedStyle\"></div>\n    <div v-show=\"canScroll\" :id=\"`chart-${_uid}-axis`\" class=\"dc-chart dc-axis-chart dc-row-axis-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcRowChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: true,\n    minHeight: 150,\n    barHeight: 20,\n    axisChartheight: 50,\n    scrollHeight: '200px',\n    scrollbarPadding: 0 // about the width of the scroll bar we are padding\n  },\n  data() {\n    return {\n      axisChart: null,\n      canScroll: false\n    }\n  },\n  methods: {\n    async createChart() {\n      // merge in default options\n      let { elastic, scrollable, minHeight, barHeight, axisChartHeight, valueAccessor, keyAccessor } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.canScroll = scrollable && group.size() * barHeight > minHeight\n\n      this.chart = new this.$dc.RowChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group)\n\n      this.$super(BaseChartMixin).createChart()\n      let rowChartMargin = this.canScroll ? Object.assign({}, this.computedMargins, { bottom: -1 }) : this.computedMargins\n      this.chart.margins(rowChartMargin)\n\n      if (elastic) {\n        this.chart.elasticX(true)\n      }\n\n      if (this.canScroll) {\n        this.chart.height(group.size() * barHeight)\n        this.chart.transitionDuration(1000)\n\n        let axisChartMargin = Object.assign({}, this.computedMargins, { top: 0 }) // enforce top margin\n        this.axisChart = new this.$dc.AxisChart(`#chart-${this._uid}-axis`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(axisChartHeight)\n          .margins(axisChartMargin)\n        if (valueAccessor) {\n          this.axisChart.valueAccessor(accessorFunc(valueAccessor))\n        }\n        if (keyAccessor) {\n          this.axisChart.keyAccessor(accessorFunc(keyAccessor))\n        }\n        if (elastic) {\n          this.axisChart.elastic(true)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      this.axisChart?.render()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.axisChart)\n      this.$emit('create', this.chart, this.axisChart)\n    }\n  },\n  computed: {\n    computedStyle() {\n      let styles = []\n      if (this.canScroll) {\n        styles.push('overflow-y: auto; overflow-x: hidden;')\n        if (this.computedOptions.scrollHeight) {\n          styles.push(`max-height: ${this.computedOptions.scrollHeight}`)\n        }\n      }\n      return styles.join('; ')\n    },\n    computedMargins() {\n      let margins = Object.assign(\n        { top: 30, right: 30, bottom: 30, left: 30 },\n        this.$options.defaultOptions?.margins,\n        this.options?.margins\n      )\n      const { scrollbarPadding } = this.computedOptions\n      if (this.canScroll && scrollbarPadding) {\n        margins.right += scrollbarPadding\n      }\n      return margins\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-row-chart.is-scrollable > svg {\n  position: relative;\n  top: 6px;\n}\n.dc-chart.dc-row-chart.is-scrollable .axis path,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick text,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick line:not(.grid-line) {\n  display: none !important;\n  stroke: none;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-stacked-bar-container\">\n    <div class=\"dc-chart dc-stacked-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc, constrain } from '../../dc-utils'\n\nexport default {\n  name: 'DcStackedBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: { x: 50 }\n  },\n  props: {\n    groups: {\n      // string[] left -> right x axis domain\n      type: Array,\n      required: true\n    },\n    stacks: {\n      // string[] | {name: string, color: string, key: string}[] bottom -> top group stack names for each key\n      type: Array,\n      required: true\n    },\n    colors: {\n      // string[], can also be provided in stacks.color (but only if every stack has provided a color value)\n      type: Array\n    },\n    keySeparator: {\n      type: String,\n      default: `;|;`\n    },\n    groupAccessor: {\n      type: [String, Function]\n    },\n    stackAccessor: {\n      type: [String, Function]\n    },\n    validateFunction: {\n      type: Function\n    }\n  },\n  methods: {\n    stackKey(stack) {\n      return typeof stack === 'string' ? stack : stack.key || stack.name || stack\n    },\n    stackName(stack) {\n      return typeof stack === 'string' ? stack : stack.name || stack.key || stack\n    },\n    computedValidateFunction(d, stack, group) {\n      if (this.validateFunction || this.computedOptions.validateFunction) {\n        let validate = this.validateFunction || this.computedOptions.validateFunction\n        return validate(d, stack, group)\n      } else {\n        const stackKey = this.stackKey(stack)\n        return this.stackAccessorFunc(d) === stackKey && this.groupAccessorFunc(d) === group\n      }\n    },\n    createChart() {\n      this.$options.dimension = this.ndx.dimension((d) => d)\n      let { add, remove, init } = this.stackReducer\n      const group = this.stackedGroup(this.$options.dimension.groupAll().reduce(add, remove, init))\n\n      const { elastic, title, barPadding, barGap, outerBarPadding } = this.computedOptions\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n      if (!this.computedAxisOptions.x?.x) {\n        this.chart.x(this.$d3.scaleBand().domain(this.groups))\n        this.chart.xUnits(this.$dc.units.ordinal)\n      }\n      let paddingDivisor = group.all().length || 1\n      this.chart.barPadding(constrain(2 / paddingDivisor, 0.1, 0.75))\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (this.computedColors.length) {\n        const colorScale = this.$d3\n          .scaleOrdinal()\n          .domain(this.stacks)\n          .range(this.stacks.map((stack, index) => this.computedColors[index % this.computedColors.length]))\n        this.chart.colors(colorScale)\n      }\n\n      function defaultTitleAccessor(d) {\n        return `${this.layer} ${d.key}: ${d.value[this.layer]}`\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      const keySeparator = this.keySeparator || ';|;'\n      const dc = this.$dc\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart\n          .selectAll('rect.bar')\n          .classed('deselected', false)\n          .classed('stack-deselected', function (d) {\n            // display stack faded if the chart has filters AND\n            // the current stack is not one of them\n            var groupKey = d.layer + keySeparator + d.x\n            return chart.filter() && !chart.filters().some((f) => f[0] === groupKey)\n          })\n          .on('click', function (evt, d) {\n            // filter this stack (default is whole row)\n            chart.filter([d.layer + keySeparator + d.x])\n            dc.redrawAll()\n          })\n      })\n\n      this.stacks.forEach((stack, index) => {\n        const groupKey = this.stackKey(stack)\n        const action = index ? 'stack' : 'group' // the first stack is just .group, the rest are .stack\n        // FIXME is there ever a reason to do this? can we use a different method for constructing/reducing the dimension and fake group after?\n        this.chart[action](group, groupKey, (d) => d.value[groupKey])\n      })\n\n      this.chart.legendables = () => {\n        const chart = this.chart\n        return this.stacks.map((stack) => {\n          const name = this.stackName(stack)\n          const groupKey = this.stackKey(stack)\n          const color = this.chart.colors()(groupKey)\n          return { chart, name, color }\n        })\n      }\n\n      this.applyLegendOptions()\n\n      this.chart.filterHandler((dimension, filters) => {\n        if (filters && filters.length) {\n          dimension.filterFunction((record) => {\n            return filters.some((c) => {\n              const [stack, groupKey] = c[0].split(this.keySeparator || ';|;')\n              // FIXME let user override this\n              return this.computedValidateFunction(record, stack, groupKey)\n            })\n          })\n        } else {\n          dimension.filter(null)\n        }\n        return filters\n      })\n    },\n    stackedGroup(group) {\n      let keySeparator = this.keySeparator\n      return {\n        all: function () {\n          var all = Object.entries(group.value()).map(([key, value]) => ({ key, value }))\n          var m = {}\n          all.forEach((kv) => {\n            const [k, s] = kv.key.split(keySeparator)\n            m[k] = m[k] || {}\n            m[k][s] = kv.value\n          })\n          return Object.keys(m).map((key) => {\n            return { key, value: m[key] }\n          })\n        }\n      }\n    }\n  },\n  computed: {\n    computedColors() {\n      let colors = this.colors || []\n      if (this.stacks && this.stacks.length && this.stacks.every((stack) => stack.color)) {\n        colors = this.stacks.map((stack) => stack.color)\n      }\n      if (!colors.length && this.stacks && this.stacks.length) {\n        colors = this.stacks.map((stack, index) => this.$d3.interpolateTurbo((index + 0.5) / this.stacks.length))\n      }\n      return colors\n    },\n    stackReducer() {\n      return {\n        add: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] +=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        remove: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] -=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        init: () => {\n          const p = {}\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              p[`${group}${this.keySeparator}${stackKey}`] = 0\n            })\n          })\n          return p\n        }\n      }\n    },\n    stackAccessorFunc() {\n      return accessorFunc(this.stackAccessor || this.computedOptions.stackAccessor || ((d) => d.stack))\n    },\n    groupAccessorFunc() {\n      return accessorFunc(this.groupAccessor || this.computedOptions.groupAccessor || ((d) => d.group))\n    }\n  }\n}\n</script>\n\n<style>\n.dc-stacked-bar-chart rect.bar.stack-deselected {\n  opacity: 0.2;\n}\n</style>\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install (Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport * from './mixins'\nexport { VueDc, dc, d3, crossfilter }\nexport default VueDc\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","calculateAxisScale","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","drawAxis","axisG","_g","select","empty","append","attr","transition","transitionDuration","transitionDelay","call","_doRender","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","axis","axisBottom","axisTop","axisRight","axisLeft","console","error","elastic","data","_doRedraw","constructor","parent","chartGroup","super","_defineProperty","_minHeight","_defaultHeightCalc","anchor","require","Object","assign","dc","renderAllNoTransitions","chartRegistry","list","forEach","chart","lastTransitionDuration","vueRender","render","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","_document$querySelect","_document$querySelect2","document","querySelector","closest","querySelectorAll","titleRoundDigits","dcConfig","DcPlugin","install","Vue","_options","options","setOptions","defaultColors","config","prototype","$dc","$d3","d3","$crossfilter","crossfilter","lastWidth","window","innerWidth","addEventListener","clearTimeout","setTimeout","script$c","name","props","axisOptions","autoTickHandler","methods","applyAxisOptions","_this$chart$xAxis","_this$chart","_this$chart$yAxis","_this$chart2","xAxisOptions","computedAxisOptions","x","yAxisOptions","y","xAxis","yAxis","applyTicks","ticks","applyFormat","format","tickFormat","applyValues","values","Array","isArray","tickValues","applySize","size","tickSize","tilt","classed","$options","dimension","autoTicks","ndx","onChange","evt","_this$chart3","_this$chart4","_group$top","_group$top$call","maxTicks","Math","max","valueAccessor","group","maxValue","ceil","min","computed","_this$computedOptions","_this$axisOptions","_this$computedOptions2","_this$axisOptions2","_this$computedOptions3","_this$axisOptions3","computedOptions","beforeDestroy","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","shadowRoot","originalRender","h","existing","beforeCreate","concat","isOldIE","navigator","test","userAgent","toLowerCase","id","css","media","styles","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","setAttribute","undefined","HEAD","head","getElementsByTagName","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","textNode","createTextNode","nodes","childNodes","removeChild","insertBefore","addStyle","accessorFunc","accessor","constrain","target","minValue","Infinity","required","String","hasResetListener","default","baseDefaultOptions","disposeDimension","resetButtonFunction","resetButtons","mounted","reset","[object Object]","createChart","addChartExtras","callOnCreate","onFilter","on","onClick","setupResetListener","renderChart","keyAccessor","title","label","height","width","digits","titleSuffix","titleDigits","_value","key","value","toFixed","computedMargins","onResetButtonClick","Promise","resolve","$emit","$nextTick","vueOptions","onCreate","charts","children","reduce","buttons","result","res","filterAll","redrawAll","button","updateButtonVisibility","hasFilter","some","instance","classList","remove","e","margin","right","bottom","_this$$options$defaul","_this$options","dim","deregister","dispose","dimensionConstructor","Function","dimensionIsArray","createDimension","dimensionAccessor","pluck","reducer","groupOptions","createGroup","groupAll","order","orderNatural","reduceSum","init","_reject","resolveTimeout","replaceGroup","ordinalToLinear","valueFunc","isGroupAll","_ord2int","_int2ord","number","entries","sort","a","b","slice","all","ret","ord2int","o","int2ord","callback","num","legend","legendOptions","applyLegendOptions","showLegend","autoWidth","gap","highlightSelected","horizontal","itemHeight","itemWidth","keyboardAccessible","legendText","legendWidth","maxItems","computedLegendOptions","autoItemWidth","_this$defaultOptions","mixins","BaseChartMixin","DimensionMixin","GroupMixin","AxisMixin","scrollable","minScrollable","scrollHeight","mouseZoom","scaleChart","hasReplacedRenderFunc","_this$computedAxisOpt","filterFunction","barPadding","barGap","outerBarPadding","ordinalValueAccessor","v","linearDomain","defaultBarGap","_uid","clientWidth","BarChart","xUnits","units","integers","centerBar","brushOn","$super","kv","canScroll","elasticY","xAxisFormat","l","focusFilter","filterHandler","_dimension","_filters","f","every","includes","applyFilter","k","_listeners","filters","_originalReplaceFilter","replaceFilter","fadeDeselectedArea","_brushSelection","bars","chartBodyG","selectAll","constants","SELECTED_CLASS","DESELECTED_CLASS","splice","redrawGroup","floor","rescale","outerPadding","_invokeFilteredListener","filterType","rangeChart","zoomScale","mouseZoomable","_this$scaleChart","_preprocessData","_generateG","_generateClipPath","_drawChart","maxEnd","focus","searchable","search","othersLimit","Number","maxHeight","othersLabel","forceFilter","keyDisplay","groupFilter","groups","others","inFilter","waitInterval","waitingTimer","dcChart","waitForChartInit","watch","_to","_from","formatFilter","resetFilters","updateListValues","watchChartChanges","array","from","acc","val","parse","slicesCap","checkOthersFilterToggled","currentFilters","fixFilters","toggleFilterFor","updateSearch","firstTry","setInterval","clearInterval","find","c","displayKey","option","shownGroups","g","RegExp","computedDigits","computedStyle","_this$dcChart","LegendMixin","groupCharts","renderArea","CompositeChart","groupChart","LineChart","color","colors","compose","limitTicksToNumDays","useD3TimeDay","snapDateCalculation","useUtcSnapping","fakeGroupingSettings","getDateBounds","date","Date","startDate","endDate","setUTCHours","setHours","days","abs","daysDifference","d1","d2","getTime","timeDay","fakeGroup","original","originalDays","toISOString","fillValue","thisDate","setDate","getDate","scaleTime","NumberDisplay","anchorName","html","singular","plural","formatNumber","makeValueAccessor","one","none","minRadius","maxRadius","innerRadius","useImprovedLabels","labelWrapSeparator","PieChart","externalRadiusPadding","radius","getRadius","ir","parseInt","buildArc","arc","outerRadius","labelPosition","centroid","coord","isNaN","wrap","text","each","el","words","split","tString","parseFloat","warn","tspan","replace","handleLabelTransition","xy","mult","_chart","redraw","container","suggestedRadius","parentNode","paddingOffset","node","nodeStyle","getComputedStyle","getPropertyValue","minHeight","barHeight","axisChartheight","scrollbarPadding","axisChart","axisChartHeight","RowChart","rowChartMargin","elasticX","axisChartMargin","_this$axisChart","stacks","keySeparator","groupAccessor","stackAccessor","validateFunction","stackKey","stack","stackName","computedValidateFunction","stackAccessorFunc","groupAccessorFunc","stackReducer","stackedGroup","scaleBand","ordinal","paddingDivisor","computedColors","colorScale","scaleOrdinal","layer","groupKey","action","legendables","record","m","s","keys","interpolateTurbo","p","registerComponents","VueDc","Proxy","get","bind","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}