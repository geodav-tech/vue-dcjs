{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../src/mixins/axis.mixin.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../node_modules/vue-runtime-helpers/dist/inject-style/browser.mjs","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../src/mixins/dimension.mixin.vue","../src/mixins/group.mixin.vue","../src/mixins/legend.mixin.vue","../src/components/dc-bar-chart/dc-bar-chart.vue","../src/components/dc-checklist/dc-checklist.vue","../src/components/dc-composite-line-chart/dc-composite-line-chart.vue","../src/components/dc-date-chart/dc-date-chart.vue","../src/components/dc-number-display/dc-number-display.vue","../src/components/dc-pie-chart/dc-pie-chart.vue","../src/components/dc-row-chart/dc-row-chart.vue","../src/components/dc-stacked-bar-chart/dc-stacked-bar-chart.vue","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, axisLeft, axisRight, axisTop, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      const axis = { axisBottom, axisTop, axisRight, axisLeft }[type]\n      this._theAxis = axis()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this._minHeight = 0\n    this._defaultHeightCalc = () => 24\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\nconst renderAllNoTransitions = () => {\n  dc.chartRegistry.list().forEach(chart => {\n    // this will set the transition duration to 0 while we render\n    // this makes the resize less flashy/distracting\n    let lastTransitionDuration = chart.transitionDuration()\n    chart.transitionDuration(0)\n    if (chart.vueRender) { // if this is a vue-dc chart we can override with a custom render function to accomplish certain fixes\n      chart.vueRender()\n    } else {\n      chart.render()\n    }\n    // but then put the duration back to whatever it was before the render\n    chart.transitionDuration(lastTransitionDuration)\n  })\n}\n\n// assign extras via Object.assign to prevent module mutated warning\n// eslint-disable-next-line no-import-assign\nObject.assign(dc, { AxisChart,  renderAllNoTransitions })\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => {\n    return document.querySelector(chart.anchor())?.closest('.example-container')?.querySelectorAll('.example-reset-button') || []\n  },\n  titleRoundDigits: -1,\n}\n\nlet dcConfig = Object.assign({}, defaultOptions)\nconst setOptions = (options) => { dcConfig = options }\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    setOptions(options)\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      let lastWidth = window.innerWidth\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        if (lastWidth !== window.innerWidth) {\n          resizeTimeout = setTimeout(() => {\n            dc.renderAllNoTransitions()\n            resizeTimeout = null\n            lastWidth = window.innerWidth\n          }, options.resizeTimeout)\n        }\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter, dcConfig, setOptions }\n","<script>\nexport default {\n  name: 'AxisMixin',\n  props: {\n    /**\n     * x: AxisOptions,\n     * y: AxisOptions,\n     *\n     * AxisOptions: {\n     *  x: scale,\n     *  y: scale,\n     *  ticks: number,\n     *  format: string, number | d => value,\n     *  values: number[],\n     *  size: number\n     * }\n     */\n    axisOptions: {\n      // can also be in this.options\n      type: Object\n    }\n  },\n  data () {\n    return {\n      autoTickHandler: null\n    }\n  },\n  methods: {\n    applyAxisOptions() {\n      let xAxisOptions = this.computedAxisOptions.x\n      let yAxisOptions = this.computedAxisOptions.y\n      if (!this.chart || (!xAxisOptions && !yAxisOptions)) {\n        // nothing to apply to, or nothing to apply\n        return\n      }\n      const xAxis = this.chart.xAxis?.()\n      const yAxis = this.chart.yAxis?.()\n\n      const applyTicks = (axis, ticks) => {\n        if (ticks || ticks === 0) {\n          axis.ticks(ticks)\n        }\n      }\n\n      const applyFormat = (axis, format) => {\n        if (typeof format === 'string') {\n          axis.tickFormat(this.$d3.format(format))\n        } else if (typeof format === 'number') {\n          axis.tickFormat = this.$d3.format(`,.${format}f`)\n        } else if (typeof format === 'function') {\n          axis.tickFormat(format)\n        }\n      }\n\n      const applyValues = (axis, values) => {\n        if (values && Array.isArray(values)) {\n          axis.tickValues(values)\n        }\n      }\n\n      const applySize = (axis, size) => {\n        if (size || size === 0) {\n          axis.tickSize(size)\n        }\n      }\n\n      if (xAxisOptions && xAxis) {\n        applyTicks(xAxis, xAxisOptions.ticks)\n        applyFormat(xAxis, xAxisOptions.format)\n        applyValues(xAxis, xAxisOptions.values)\n        applySize(xAxis, xAxisOptions.size)\n        if (xAxisOptions.tilt) {\n          this.$d3.select(this.chart.anchor()).classed('tilted-x-axis', true)\n        }\n        if (xAxisOptions.x && typeof this.chart.x === 'function') {\n          this.chart.x(xAxisOptions.x(this.$options.dimension))\n        }\n      }\n\n      if (yAxisOptions && yAxis) {\n        applyTicks(yAxis, yAxisOptions.ticks)\n        applyFormat(yAxis, yAxisOptions.format)\n        applyValues(yAxis, yAxisOptions.values)\n        applySize(yAxis, yAxisOptions.size)\n        if (yAxisOptions.y && typeof this.chart.y === 'function') {\n          this.chart.y(yAxisOptions.y(this.$options.dimension))\n        }\n      }\n\n      if (yAxis && this.computedAxisOptions.autoTicks && this.ndx) {\n        this.ndx.onChange(evt => {\n          if (evt === 'filtered') {\n            const maxTicks = Math.max(yAxisOptions?.ticks || 0, 10)\n            const valueAccessor = this.chart?.valueAccessor()\n            const group = this.chart?.group()\n            const top = group?.top?.(1)?.[0]\n            let maxValue = maxTicks\n            try {\n              maxValue = Math.ceil(valueAccessor(top))\n            } catch {\n              maxValue = maxTicks\n            }\n            const ticks = Math.min(maxTicks, Math.max(1, maxValue))\n            yAxis.ticks(ticks)\n          }\n        })\n      }\n    }\n  },\n  computed: {\n    computedAxisOptions() {\n      return {\n        x: Object.assign({}, this.computedOptions?.xAxis, this.axisOptions?.x),\n        y:  Object.assign({}, this.computedOptions?.yAxis, this.axisOptions?.y),\n        autoTicks: this.computedOptions?.autoTicks || this.axisOptions?.autoTicks || false\n      }\n    }\n  },\n  beforeDestroy () {\n    if (this.autoTickHandler) {\n      this.autoTickHandler()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.tilted-x-axis .axis.x .tick text{\n  text-anchor: end;\n  transform: rotate(-33deg) translate(-4px, -2px);\n}\n\n</style>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","const isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nexport default createInjector;\n//# sourceMappingURL=browser.mjs.map\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc (accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain (target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat (array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nimport { dcConfig } from '../plugins/dc.plugin.js'\n\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: []\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    async drawChart() {\n      // clear chart?\n      await this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (dcConfig.useResetListener && typeof dcConfig.resetSelector === 'function') {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width, digits, titleSuffix } = this.computedOptions\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = keyAccessor ? accessorFunc(keyAccessor)(d) : d.key\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins && this.chart.margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n\n      // allow our custom `renderAllNoTransitions` to call the overridden render func for vue-based charts\n      this.chart.vueRender = () => this.render()\n    },\n    onResetButtonClick() {},\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.computedOptions?.onCreate?.(this.chart)\n      this.$emit('create', this.chart)\n    },\n    setupResetListener() {\n      let charts = this.chart?.children ? [this.chart, ...this.chart.children()] : [this.chart]\n      try {\n        const { resetSelector } = dcConfig\n        this.resetButtons = charts.reduce((buttons, chart) => {\n          let result = resetSelector(chart)\n          if (typeof result.forEach !== 'function') {\n            buttons.push(result)\n          } else {\n            result.forEach((res) => {\n              buttons.push(res)\n            })\n          }\n          return buttons\n        }, [])\n\n        // ensure we can remove this later\n        this.resetButtonFunction = () => {\n          charts.forEach((chart) => {\n            chart.filterAll()\n          })\n          this.$dc.redrawAll()\n        }\n\n        this.resetButtons.forEach((button) => {\n          button.addEventListener('click', this.resetButtonFunction)\n        })\n        const updateButtonVisibility = () => {\n          let hasFilter = charts.some((chart) => chart.hasFilter())\n          this.resetButtons.forEach((instance) => {\n            if (hasFilter) {\n              instance.classList.remove('dc-reset-is-hidden')\n            } else {\n              instance.classList.add('dc-reset-is-hidden')\n            }\n          })\n        }\n\n        charts.forEach((chart) => {\n          chart.on('filtered.reset', updateButtonVisibility)\n        })\n        updateButtonVisibility() // update this on startup as well\n      } catch (e) {\n        console.error('Could not attach reset listener using resetSelector', e)\n      }\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","<script>\nexport default {\n  name: 'DimensionMixin',\n  props: {\n    dimensionConstructor: {\n      type: [String, Function] // (d) => value\n    },\n    dimensionIsArray: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    createDimension() {\n      let dimensionAccessor = (d) => d\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    }\n  }\n}\n</script>\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'GroupMixin',\n  props: {\n    reducer: {\n      type: [String, Function, Object]\n    },\n    groupOptions: {\n      /**\n       * order: d => orderValue,\n       * orderNatural: boolean (not compatable with order),\n       */\n      type: Object\n    }\n  },\n  methods: {\n    createGroup(dimension, groupAll = false) {\n      let group = groupAll ? dimension.groupAll() : dimension.group()\n\n      if (this.groupOptions && this.groupOptions.order) {\n        if (typeof this.groupOptions.order === 'string') {\n          group.order((d) => d[this.groupOptions.order])\n        } else if (typeof this.groupOptions.order === 'function') {\n          group.order(this.groupOptions.order)\n        }\n      } else if (this.groupOptions && this.groupOptions.orderNatural) {\n        group.orderNatural()\n      }\n\n      if (typeof this.reducer === 'string' || typeof this.reducer === 'function') {\n        group.reduceSum(accessorFunc(this.reducer))\n      } else if (this.reducer.add && this.reducer.remove && this.reducer.init) {\n        let { add, remove, init } = this.reducer\n        group.reduce(add, remove, init)\n      }\n      return new Promise((resolve, _reject) => {\n        let resolveTimeout = setTimeout(() => {\n          return resolve(group)\n        })\n        this.$emit('group-created', group, (replaceGroup) => {\n          // parent called back with a replacement\n          clearTimeout(resolveTimeout)\n          return resolve(replaceGroup)\n        })\n      })\n    },\n    // https://github.com/dc-js/dc.js/blob/develop/web-src/examples/focus-ordinal-bar.html\n    ordinalToLinear(group, valueFunc, isGroupAll = false) {\n      var _ord2int, _int2ord\n      return {\n        top: function (number = 1) {\n          if (isGroupAll) {\n            return Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n              .slice(0, number)\n          } else {\n            return group.order((d) => valueFunc(d)).top(number)\n          }\n        },\n        all: function () {\n          var ret = []\n          if (isGroupAll) {\n            ret = Object.entries(group.value())\n              .map(([key, value]) => ({ key, value }))\n              .sort((a, b) => valueFunc(b.value) - valueFunc(a.value))\n          } else {\n            ret = group.order((d) => valueFunc(d)).top(Infinity)\n          }\n          _ord2int = {}\n          _int2ord = []\n          ret.forEach(function (d, i) {\n            _ord2int[d.key] = i\n            _int2ord[i] = d.key\n          })\n          return ret\n        },\n        ord2int: function (o) {\n          if (!_ord2int) {\n            this.all()\n          }\n          return _ord2int[o]\n        },\n        int2ord: function (i) {\n          if (!_int2ord) {\n            this.all()\n          }\n          return _int2ord[i]\n        },\n        order: function(callback) {\n          if (isGroupAll) {\n            // if this is a groupAll, we'll have to manually figure this out\n            // generally this is used for dc-checklist\n            const order = Object.entries(group.value()).map(([key, value]) => ({ key, value })).sort((a, b) => callback(b.value) - callback(a.value))\n            // since we just turned the return into an array, we have to fake some dc functions we expect to use on the array\n            // dc-checklist uses top, but we'll also add .all in case\n            order.top = (num) => order.slice(0, num)\n            order.all = () => order\n            return order\n          } else {\n            // if this isn't a groupAll, it has an order function and you can just use that\n            return group.order(callback)\n          }\n        }\n      }\n    }\n  }\n}\n</script>\n","<script>\nexport default {\n  name: 'LegendMixin',\n  props: {\n    legend: {\n      type: Boolean\n    },\n    legendOptions: {\n      type: Object\n    }\n  },\n  methods: {\n    applyLegendOptions() {\n      if (this.computedOptions.showLegend || this.computedOptions.legend || this.legend) {\n        let legend = this.$dc.legend()\n        let {\n          autoWidth,\n          gap,\n          highlightSelected,\n          horizontal,\n          itemHeight,\n          itemWidth,\n          keyboardAccessible,\n          legendText,\n          legendWidth,\n          maxItems,\n          x,\n          y\n        } = this.computedLegendOptions\n\n        // use !== undefined to allow false/0 values to be accepted\n\n        if (autoWidth !== undefined) {\n          legend.autoItemWidth(autoWidth)\n        } else if (itemWidth !== undefined) {\n          legend.itemWidth(itemWidth)\n        }\n\n        if (gap !== undefined) {\n          legend.gap(gap)\n        }\n\n        if (highlightSelected !== undefined) {\n          legend.highlightSelected(highlightSelected)\n        }\n\n        if (horizontal !== undefined) {\n          legend.horizontal(horizontal)\n        }\n        if (itemHeight !== undefined) {\n          legend.itemHeight(itemHeight)\n        }\n\n        if (keyboardAccessible !== undefined) {\n          legend.keyboardAccessible(keyboardAccessible)\n        }\n\n        if (legendText !== undefined) {\n          legend.legendText(legendText)\n        }\n        if (legendWidth !== undefined) {\n          legend.legendWidth(legendWidth)\n        }\n        if (maxItems !== undefined) {\n          legend.maxItems(maxItems)\n        }\n        if (x !== undefined) {\n          legend.x(x)\n        }\n        if (y !== undefined) {\n          legend.y(y)\n        }\n        this.chart.legend(legend)\n      }\n    }\n  },\n  computed: {\n    computedLegendOptions() {\n      return Object.assign({}, this.defaultOptions?.legendOptions, this.options?.legendOptions, this.legendOptions)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-scroll-bar-chart-container\">\n    <div v-if=\"computedOptions.scrollable\" style=\"position: relative; z-index: 0\">\n      <div class=\"dc-scroll-bar-range\" :class=\"{ hidden: !canScroll }\" :id=\"`chart-${_uid}-range`\"></div>\n      <!-- fill in the scroll-bar space if we cannot scroll -->\n      <div class=\"dc-scroll-bar-range-filler\" :class=\"{ hidden: canScroll }\"></div>\n    </div>\n    <div class=\"dc-chart dc-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { AxisMixin, BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\nimport { dcConfig } from '../../plugins/dc.plugin.js'\n\nexport default {\n  name: 'DcBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: false,\n    minScrollable: 12, // will not scroll if less than this number\n    scrollHeight: 12, // how tall the scroll chart is\n    mouseZoom: true\n  },\n  data() {\n    return {\n      scaleChart: null,\n      top: 0,\n      hasReplacedRenderFunc: false\n    }\n  },\n  methods: {\n    async createChart() {\n      this.hasReplacedRenderFunc = false\n      let {\n        elastic,\n        minScrollable,\n        scrollHeight,\n        groupAll,\n        valueAccessor,\n        title,\n        titleSuffix,\n        filterFunction,\n        mouseZoom,\n        barPadding,\n        barGap,\n        outerBarPadding,\n        digits\n      } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let ordinalValueAccessor = accessorFunc(valueAccessor || ((v) => v))\n      const group = this.ordinalToLinear(await this.createGroup(this.$options.dimension, groupAll), ordinalValueAccessor, groupAll)\n\n      this.top = group.all().length\n\n      const linearDomain = [-0.52, this.top - 0.5]\n      let defaultBarGap = this.top ? document.querySelector(`#chart-${this._uid}`).clientWidth / minScrollable / this.top : 0\n      defaultBarGap = Math.max(Math.ceil(defaultBarGap), 1)\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleLinear().domain(linearDomain))\n        .xUnits(this.$dc.units.integers)\n        .centerBar(true)\n        .brushOn(false)\n        .gap(defaultBarGap)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      this.chart.keyAccessor((kv) => group.ord2int(kv.key))\n      this.chart.valueAccessor((kv) => ordinalValueAccessor(kv.value))\n      this.chart.transitionDuration(this.canScroll ? 50 : 250)\n\n      const titleDigits =  digits || digits === 0 ? digits : dcConfig.titleRoundDigits\n      function defaultTitleAccessor(d) {\n        const key = d.key\n        // these require valueAccessor to pass d.value not d.... confusing\n        let value = valueAccessor ? accessorFunc(valueAccessor)(d.value) : d.value\n        if (value?.toFixed && titleDigits >= 0) {\n          value = value.toFixed(titleDigits)\n        }\n        let title = `${key}: ${value}`\n        if (titleSuffix) {\n          title += titleSuffix\n        }\n        return title\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      let xAxisFormat = accessorFunc(this.computedAxisOptions.x?.format || (d => d))\n      this.chart.xAxis().tickFormat(d => xAxisFormat(group.int2ord(d))).ticks(this.top)\n      if (this.top <= minScrollable / 4) {\n        const l = this.top || 1\n        this.chart.barPadding(minScrollable / 2 / l)\n      }\n\n      let focusFilter = []\n      this.chart.filterHandler(function (_dimension, _filters) {}) // disable built in filtering\n\n      // overwrite with our own filtering logic\n      this.chart.hasFilter = function (f) {\n        if (Array.isArray(f)) {\n          return f.every((filter) => focusFilter.includes(filter))\n        } else if (f) {\n          return focusFilter.includes(f)\n        } else {\n          return focusFilter.length\n        }\n      }\n\n      this.chart.applyFilter = function () {\n        if (focusFilter.length) {\n          this.dimension().filterFunction(function (k) {\n            if (filterFunction) {\n              return filterFunction(focusFilter, k)\n            } else {\n              return focusFilter.includes(k)\n            }\n          })\n        } else {\n          this.dimension().filter(null)\n        }\n        // hook this custom filter logic back into the on('filtered') event handler\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this._listeners.call('filtered', this, this, focusFilter)\n      }\n\n      this.chart.filterAll = function () {\n        focusFilter = []\n        this.applyFilter()\n      }\n\n      // .filters now provides the actual keys as filters (dc-checklist support)\n      this.chart.filters = () => [...focusFilter]\n\n      // keep the original replaceFilter function for zoom settings\n      this.chart._originalReplaceFilter = this.chart.replaceFilter\n      this.chart.replaceFilter = function (filters) {\n        // replaceFilter can be called by the dc-checklist\n        // if everything is an array, it's a real request to replace filters the way we would expect\n        if (filters.every(filter => Array.isArray(filter))) {\n          focusFilter = []\n          // filters should look something like [['management', 'team2']] (double array)\n          filters.forEach(filter => {\n            // push inner array elements to the focus filter\n            focusFilter.push(...filter)\n          })\n          this.applyFilter() // apply the focus filter\n          return this // return the chart\n        } else {\n          // if this is not an array, then this is really a request to change the scroll area\n          return this._originalReplaceFilter(filters)\n        }\n      }\n\n      const dc = this.$dc\n      const d3 = this.$d3\n      this.chart.fadeDeselectedArea = function (_brushSelection) {\n        let bars = this.chartBodyG().selectAll('rect.bar')\n        if (focusFilter.length) {\n          bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n            return focusFilter.includes(d.data.key)\n          })\n          bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n            return !focusFilter.includes(d.data.key)\n          })\n        } else {\n          bars.classed(dc.constants.SELECTED_CLASS, false)\n          bars.classed(dc.constants.DESELECTED_CLASS, false)\n        }\n      }\n\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart.selectAll('rect.bar').on('click.ordinal-select', function (e, d) {\n          var i = focusFilter.indexOf(d.data.key)\n          if (i >= 0) {\n            focusFilter.splice(i, 1)\n          } else {\n            focusFilter.push(d.data.key)\n          }\n          chart.applyFilter()\n          chart.redrawGroup()\n        })\n      })\n\n      this.chart.on('preRedraw.vue-dcjs', function (chart) {\n        const domain = chart.x().domain()\n        const min = Math.ceil(domain[0])\n        const max = Math.floor(domain[1])\n        chart.xAxis().tickValues(d3.range(min, max + 1))\n        chart.rescale() // allow x axis to match ordering changes\n      })\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      // FIXME text wrapping x axis in shared thing?\n\n      if (this.canScroll) {\n        let { top, bottom, left, right } = this.computedMargins\n        this.chart.margins({ top: 0, bottom, left, right })\n\n        // do not send focus events as filter events to anyone listening to this.chart.on('filtered')\n        // http://dc-js.github.io/dc.js/docs/html/base_base-mixin.js.html#sunlight-1-line-844\n        this.chart._invokeFilteredListener = function (f) {\n          // ignore 'RangedFilter' type. it's coming from the scale chart as long as brushing is disabled\n          if (f !== undefined && f.filterType !== 'RangedFilter') {\n            return this._listeners.call('filtered', this, this, f)\n          }\n        }\n\n        this.scaleChart = new this.$dc.BarChart(`#chart-${this._uid}-range`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(scrollHeight + top)\n          .margins({ left, top, right, bottom: 2 })\n          .x(this.$d3.scaleLinear().domain(linearDomain))\n          .xUnits(this.$dc.units.integers)\n          .keyAccessor((kv) => group.ord2int(kv.key))\n          .centerBar(true)\n          .valueAccessor((kv) => ordinalValueAccessor(kv.value))\n          .brushOn(true)\n          .transitionDuration(0)\n          .gap(1)\n\n        this.scaleChart.filterHandler(function () {}) // ensure the scale chart has no filterFunction (it will mess up scaling on all charts)\n        this.scaleChart.yAxis().ticks(0)\n        this.scaleChart.xAxis().ticks(0)\n\n        this.chart.rangeChart(this.scaleChart)\n        this.chart.zoomScale([Math.min(8, Math.ceil(this.top / 12)), Math.min(this.top, 12)])\n        if (elastic) {\n          this.scaleChart.elasticY(true)\n        }\n        if (mouseZoom) {\n          this.chart.mouseZoomable(this.canScroll)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      if (this.canScroll) {\n        if (!this.hasReplacedRenderFunc) {\n          // Calling `dc.renderAll()` messed up mouse zooming with this chart\n          // so this fixes things when using the window resize handler which calls dc.renderAll() to resize the charts\n          // rewriting this function without `this._configureMouseZoom()` seems to work?\n          // http://dc-js.github.io/dc.js/docs/html/base_coordinate-grid-mixin.js.html#sunlight-1-line-1150\n          // https://github.com/dc-js/dc.js/issues/1857\n          this.chart._doRender = function () {\n            this.resetSvg()\n            this._preprocessData()\n            this._generateG()\n            this._generateClipPath()\n            this._drawChart(true)\n            return this\n          }\n          this.hasReplacedRenderFunc = true\n        }\n        this.scaleChart?.render()\n        const maxEnd = Math.min(12, Math.floor(this.top / Math.min(8, Math.ceil(this.top / 12))))\n        this.chart.focus([-1, maxEnd])\n      }\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.scaleChart)\n      this.$emit('create', this.chart, this.scaleChart)\n    }\n  },\n  computed: {\n    canScroll() {\n      return this.computedOptions.scrollable && this.top >= this.computedOptions.minScrollable\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart-container.dc-scroll-bar-chart-container {\n  position: relative;\n  z-index: 0;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler.hidden,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .axis,\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler .axis {\n  display: none;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range {\n  z-index: 1;\n  position: relative;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range .custom-brush-handle {\n  cursor: ew-resize;\n  stroke: black;\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range g.brush {\n  fill: rgba(100, 100, 100, 0.1);\n}\n\n.dc-scroll-bar-chart-container .dc-scroll-bar-range svg {\n  display: block;\n}\n.dc-scroll-bar-chart-container .dc-scroll-bar-range-filler {\n  height: 12px;\n}\n</style>\n","<template>\n  <div class=\"dc-check-list-container\" :style=\"computedStyle\">\n    <slot name=\"search\">\n      <div class=\"dc-search-input-container\">\n        <label for=\".dc-search-input\" class=\"dc-search-input-label\">Search</label>\n        <input class=\"dc-search-input\" v-model=\"groupFilter\" @input=\"updateSearch\" />\n      </div>\n    </slot>\n    <div class=\"dc-checkbox-container\">\n      <div class=\"dc-checkbox\" v-for=\"item in shownGroups\" :key=\"item.key\" @click=\"toggleFilterFor(item.key)\">\n        <slot name=\"option\" v-bind:option=\"item\" v-bind:value=\"inFilter.includes(item.key)\">\n          <span class=\"dc-option-box\" :class=\"{ selected: inFilter.includes(item.key) }\" />\n          <span class=\"dc-option-label\" :class=\"{ selected: inFilter.includes(item.key) }\">\n            {{ displayKey(item) }} ({{ item.value | formatFilter(computedDigits) }})\n          </span>\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { flat, accessorFunc } from '../../dc-utils'\nexport default {\n  name: 'DcChecklist',\n  props: {\n    chart: {\n      type: [String, Object],\n      required: true\n    },\n    searchable: {\n      type: Boolean,\n      default: true\n    },\n    search: {\n      // if you want to override search string functionality\n      type: String,\n      default: ''\n    },\n    othersLimit: {\n      // define an \"others\" group cutoff. values past this number are considered in an \"others\" group\n      // not needed if options.slicesCap is defined\n      type: Number\n    },\n    digits: {\n      type: Number\n    },\n    maxHeight: {\n      // will make checkboxes scrollable with a max-height\n      type: [String, Number],\n      default: null\n    },\n    othersLabel: {\n      type: String\n    },\n    forceFilter: { // d => boolean to filter out empty/fake groups\n      type: Function,\n      default: null\n    },\n    keyDisplay: { // d => string to display and search key\n      type: Function,\n      default: null\n    }\n  },\n  data() {\n    return {\n      groupFilter: '',\n      groups: [],\n      others: [], // groups for pie charts which list an \"others\" category\n      inFilter: [],\n      waitInterval: null,\n      waitingTimer: 1\n    }\n  },\n  mounted() {\n    if (this.dcChart) {\n      this.reset()\n    } else {\n      this.waitForChartInit(true)\n    }\n  },\n  watch: {\n    dcChart(_to, _from) {\n      this.reset()\n    },\n    search() {\n      if (this.search != this.groupFilter) {\n        this.groupFilter = this.search\n      }\n    }\n  },\n  filters: {\n    formatFilter(value, digits) {\n      if (digits || digits === 0) {\n        return value.toFixed(digits)\n      } else {\n        return value\n      }\n    }\n  },\n  methods: {\n    reset() {\n      this.resetFilters()\n      this.updateListValues()\n      this.watchChartChanges()\n    },\n    resetFilters() {\n      // set the inFilter to match the chart\n      this.inFilter = Array.from(new Set(flat(this.dcChart.filters())))\n    },\n    updateListValues() {\n      // deep copy the groups so values do not get messed up when filtering\n      let groups = this.dcChart.group()\n        .order((value) => this.valueAccessor({ value }))\n        .top(Infinity)\n      if (this.forceFilter && typeof this.forceFilter === 'function') {\n        groups = groups.filter(this.forceFilter)\n      }\n      this.groups = JSON.parse(JSON.stringify(groups))\n      if (this.options.slicesCap || this.othersLimit) {\n        this.others = this.groups.slice(this.options.slicesCap || this.othersLimit).map((d) => d.key)\n      } else {\n        this.others = []\n      }\n    },\n    checkOthersFilterToggled() {\n      // fix issue where a category would get excluded by mistake when:\n      // - check a box in the 'others' category from this list\n      // - click the 'others' category on the pie chart after\n      // check for this case and add back in the category you clicked if necessary\n      let currentFilters = this.dcChart.filters()\n      let othersLabel = this.othersLabel || this.options.othersLabel || 'others'\n      const fixFilters = this.others.filter((k) => !currentFilters.includes(k) && this.inFilter.includes(k))\n      if (currentFilters.includes(othersLabel) && fixFilters.length) {\n        currentFilters.push(...fixFilters)\n        this.inFilter = currentFilters\n        this.dcChart.replaceFilter([currentFilters])\n      }\n    },\n    toggleFilterFor(key) {\n      if (this.inFilter.includes(key)) {\n        this.inFilter = this.inFilter.filter((k) => k !== key)\n      } else {\n        this.inFilter.push(key)\n      }\n\n      // yes this has to be an array of arrays thus [inFilter]\n      // https://stackoverflow.com/questions/38920359/how-to-filter-multiple-values-in-a-dc-crossfilter-dimension\n      // marked answer, first part mentions this\n      this.dcChart.replaceFilter([this.inFilter])\n      this.$nextTick(() => this.$dc.redrawAll())\n    },\n    updateSearch() {\n      this.$emit('update:search', this.groupFilter)\n      this.$emit('update-search', this.groupFilter)\n    },\n    watchChartChanges() {\n      this.dcChart.on(`renderlet.checklist_${this._uid}`, () => {\n        this.updateListValues()\n      })\n      this.dcChart.on(`filtered.checklist_${this._uid}`, () => {\n        this.$nextTick(() => {\n          this.checkOthersFilterToggled()\n          this.resetFilters()\n          this.updateListValues()\n        })\n      })\n    },\n    waitForChartInit(firstTry = false) {\n      this.waitInterval = setInterval(\n        () => {\n          this.waitingTimer = ((this.waitingTimer + 1) % 100) + 1\n          this.$nextTick(() => {\n            if (this.dcChart) {\n              this.reset()\n              clearInterval(this.waitInterval)\n              this.waitInterval = null\n            }\n          })\n        },\n        firstTry ? 50 : 300\n      )\n    }\n  },\n  computed: {\n    dcChart() {\n      // add waitingTimer (reactive) to the computed property as a dependency since this.$dc.chartRegistry.list() is not reactive\n      if (typeof this.chart === 'string' && this.waitingTimer) {\n        return this.$dc.chartRegistry.list().find((c) => c.name === this.chart)\n      } else {\n        return this.chart\n      }\n    },\n    displayKey () {\n      return (option) => {\n        return this.keyDisplay ? this.keyDisplay(option) : option?.key || ''\n      }\n    },\n    shownGroups() {\n      if (!this.groupFilter || !this.groupFilter.length) {\n        return this.groups\n      } else {\n        return this.groups.filter((g) => {\n          const reg = new RegExp(this.groupFilter, 'gi')\n          return reg.test(this.displayKey(g))\n        })\n      }\n    },\n    valueAccessor() {\n      return accessorFunc(this.options.valueAccessor || ((d) => d.value))\n    },\n    computedDigits() {\n      if (this.digits || this.digits === 0) {\n        return this.digits\n      } else {\n        return this.options.digits\n      }\n    },\n    computedStyle() {\n      let styles = []\n      if (this.maxHeight) {\n        styles.push('overflow-y: auto')\n        if (typeof this.maxHeight === 'number') {\n          styles.push(`max-height: ${this.maxHeight}px`)\n        } else {\n          styles.push(`max-height: ${this.maxHeight}`)\n        }\n      }\n\n      return styles.join('; ')\n    },\n    options() {\n      return this.dcChart?.vueOptions || {}\n    }\n  },\n  beforeDestroy() {\n    if (this.waitInterval) {\n      clearInterval(this.waitInterval)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-check-list-container {\n  text-align: left;\n  width: 100%;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input-label {\n  display: block;\n  font-weight: bold;\n  font-size: 0.85rem;\n  margin-bottom: -0.25rem;\n}\n.dc-check-list-container .dc-search-input-container .dc-search-input {\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n  width: calc(100% - 1.25rem);\n  border-color: black;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:nth-child(2n) {\n  background-color: whitesmoke;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box {\n  display: inline-block;\n  width: 1rem;\n  height: 1rem;\n  border-radius: 0.25rem;\n  margin: 0.25rem;\n  border: 2px solid black;\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox .dc-option-box.selected {\n  background-color: rgb(56, 140, 230, 1);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box {\n  background-color: rgba(56, 140, 230, 0.25);\n}\n.dc-check-list-container .dc-checkbox-container .dc-checkbox:hover .dc-option-box.selected {\n  background-color: rgba(56, 140, 230, 0.75);\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-composite-line-container\">\n    <div class=\"dc-chart dc-composite-line-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcCompositeLineChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: {\n      x: 50\n    }\n  },\n  props: {\n    /**\n     * {\n     *    name: string (will be displayed)\n     *    valueAccessor: string | ((d) => value)\n     *    color: string\n     * }\n     */\n    groups: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {\n      groupCharts: []\n    }\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n\n      let { elastic, keyAccessor, renderArea } = this.computedOptions\n\n      this.chart = new this.$dc.CompositeChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n\n      if (!this.computedAxisOptions.x?.x) {\n        let keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d.key))\n        let top = keyAccessor(this.$options.dimension.top(1)[0])\n        let bottom = keyAccessor(this.$options.dimension.bottom(1)[0])\n        this.chart.x(this.$d3.scaleLinear().domain([bottom, top]))\n      }\n\n      this.groupCharts = this.groups.map((chartGroup) => {\n        let groupChart = new this.$dc.LineChart(this.chart)\n          .group(group, chartGroup.name)\n          .valueAccessor(accessorFunc(chartGroup.valueAccessor || ((d) => d.value)))\n          .keyAccessor(accessorFunc(keyAccessor || ((d) => d.key)))\n        if (renderArea || chartGroup.renderArea) {\n          groupChart.renderArea(true)\n        }\n        if (chartGroup.color) {\n          groupChart.colors(chartGroup.color)\n        }\n        return groupChart\n      })\n\n      this.chart.compose(this.groupCharts)\n      this.applyLegendOptions()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.groupCharts)\n      this.$emit('create', this.chart, this.groupCharts)\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container dc-date-chart-container\">\n    <div class=\"dc-chart dc-date-chart\" :id=\"`chart-${_uid}`\" />\n  </div>\n</template>\n\n<script>\nimport { accessorFunc } from '../../dc-utils'\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin } from '../../mixins'\n\nexport default {\n  name: 'DcDateChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin],\n  defaultOptions: {\n    elastic: true,\n    renderArea: true,\n    limitTicksToNumDays: true, // limit the number of ticks to match the number of days under maxTicks\n    useD3TimeDay: true, // if passed no dimensionConstructor or string, will use d3.timeDay to construct dimension\n    snapDateCalculation: false,\n    useUtcSnapping: false,\n    fakeGroupingSettings: null // { startDate, endDate, fillValue }\n  },\n  methods: {\n    getDateBounds() {\n      const keyAccessor = accessorFunc(this.computedOptions.keyAccessor || ((d) => d?.date))\n\n      let top = new Date(keyAccessor(this.$options.dimension.top(1)[0]))\n      let bottom = new Date(keyAccessor(this.$options.dimension.bottom(1)[0]))\n\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        bottom = new Date(this.computedOptions.fakeGroupingSettings.startDate)\n        top = new Date(this.computedOptions.fakeGroupingSettings.endDate)\n      }\n\n      let { snapDateCalculation, useUtcSnapping } = this.computedOptions\n      if (snapDateCalculation) {\n        if (useUtcSnapping) {\n          top.setUTCHours(0, 0, 0, 0)\n          bottom.setUTCHours(23, 59, 59, 999)\n        } else {\n          top.setHours(0, 0, 0, 0)\n          bottom.setHours(23, 59, 59, 999)\n        }\n      }\n      // floor?\n      let days = Math.ceil(Math.abs(this.daysDifference(top, bottom)))\n      return { top, bottom, days }\n    },\n    daysDifference(d1, d2) {\n      if (!d1 || !d2 || !d1.getTime || !d2.getTime) {\n        return null\n      }\n      return (d2.getTime() - d1.getTime()) / 1000 / 60 / 60 / 24\n    },\n    createDimension() {\n      // override DimensionMixin to include d3.timeDay defaults for this chart\n      let { useD3TimeDay } = this.computedOptions\n      const timeDay = (d) => this.$d3.timeDay(new Date(d))\n\n      let dimensionAccessor = useD3TimeDay ? (d) => timeDay(this.$dc.pluck('date')(d)) : this.$dc.pluck('date')\n\n      if (typeof this.dimensionConstructor === 'string') {\n        dimensionAccessor = useD3TimeDay\n          ? (d) => timeDay(this.$dc.pluck(this.dimensionConstructor)(d))\n          : this.$dc.pluck(this.dimensionConstructor)\n      } else if (typeof this.dimensionConstructor === 'function') {\n        dimensionAccessor = this.dimensionConstructor\n      }\n      return this.ndx.dimension(dimensionAccessor, this.dimensionIsArray)\n    },\n    // the user can specify a date range and fillValue to fill out any missing days from the data\n    // this will zero-out any missing days making the chart look more accurate!\n    fakeGroup (group, fakeGroupingSettings) {\n      let startDate = new Date(fakeGroupingSettings.startDate)\n      let endDate = new Date(fakeGroupingSettings.endDate)\n      const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))\n      return {\n        all() {\n          const original = group.all()\n          const originalDays = original.map(kv => kv.key.toISOString())\n          const result = []\n          const fillValue = fakeGroupingSettings.fillValue || {}\n          for (let i = 0; i <= days; i++) {\n            const thisDate = new Date(startDate)\n            thisDate.setDate(startDate.getDate() + i)\n\n            if (originalDays.includes(thisDate.toISOString())) {\n              continue // this date is already covered, we'll skip it\n            }\n            if (typeof fillValue === 'object') {\n              result.push(Object.assign({}, fillValue, { date: thisDate }))\n            } else  if (typeof fillValue === 'function') {\n              result.push(fillValue(thisDate))\n            }\n          }\n          // to draw the line left to right properly these MUST be sorted\n          return original.concat(result).sort((a, b) => a.key - b.key)\n        },\n        domain () {\n          return [startDate, endDate]\n        }\n      }\n    },\n    async createChart() {\n      let { elastic, renderArea } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      let group = await this.createGroup(this.$options.dimension)\n      if (this.computedOptions.fakeGroupingSettings && this.computedOptions.fakeGroupingSettings.startDate && this.computedOptions.fakeGroupingSettings.endDate) {\n        group = this.fakeGroup(group, this.computedOptions.fakeGroupingSettings)\n      }\n      let { top, bottom, days } = this.getDateBounds()\n\n      this.chart = new this.$dc.LineChart(`#chart-${this._uid}`)\n        .dimension(this.$options.dimension)\n        .group(group)\n        .x(this.$d3.scaleTime().domain([bottom, top]))\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (renderArea) {\n        this.chart.renderArea(true)\n      }\n\n      if (this.computedOptions.limitTicksToNumDays) {\n        let maxTicks = this.computedAxisOptions.x?.ticks || 10\n        this.chart.xAxis().ticks(Math.min(maxTicks, days))\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <span class=\"dc-number-display\" :id=\"`chart-${_uid}`\"></span>\n</template>\n\n<script>\nimport { BaseChartMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils'\n\nexport default {\n  name: 'DcNumberDisplay',\n  mixins: [BaseChartMixin, GroupMixin],\n  methods: {\n    async createChart() {\n      const group = await this.createGroup(this.ndx, true)\n      this.chart = new this.$dc.NumberDisplay(`#chart-${this._uid}`).group(group)\n\n      this.chart.anchorName = () => {\n        return `#chart-${this._uid}`\n      }\n\n      this.$super(BaseChartMixin).createChart()\n\n      let { html, singular, plural, formatNumber, valueAccessor } = this.computedOptions\n\n      // resetting the value accessor whenever the data changes is required to recompute the unfilteredTotal\n      const makeValueAccessor = () => (d) => accessorFunc(valueAccessor || ((d) => d))(d, group.value())\n      this.ndx.onChange(type => {\n        if (type === 'dataAdded' || type === 'dataRemoved') {\n          this.chart.valueAccessor(makeValueAccessor())\n        }\n      })\n      this.chart.valueAccessor(makeValueAccessor())\n\n      if (html) {\n        this.chart.html(html)\n      } else if (singular) {\n        plural = plural || singular + 's'\n        this.chart.html({ one: `%number ${singular}`, some: `%number ${plural}`, none: `%number ${plural}` })\n      }\n\n      if (formatNumber) {\n        let format = typeof formatNumber === 'string' ? this.$d3.format(formatNumber) : formatNumber\n        this.chart.formatNumber(format)\n      }\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"dc-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-pie-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { constrain } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcPieChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    minRadius: 0,\n    maxRadius: Infinity,\n    innerRadius: 0,\n    slicesCap: 10,\n    othersLabel: 'others',\n    useImprovedLabels: true,\n    labelWrapSeparator: ';|;' // if using improved labels you can separate key and value by this separator\n  },\n  methods: {\n    async createChart() {\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.chart = new this.$dc.PieChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group).externalRadiusPadding(12)\n      this.$super(BaseChartMixin).createChart()\n\n      let radius = this.getRadius()\n      this.chart.radius(radius)\n      this.chart.width(radius)\n      this.chart.height(radius)\n      let { innerRadius, slicesCap, othersLabel, useImprovedLabels } = this.computedOptions\n      if (slicesCap) {\n        this.chart.slicesCap(slicesCap)\n      }\n      if (othersLabel) {\n        this.chart.othersLabel(othersLabel)\n      }\n      if (innerRadius) {\n        // either exact number or 'X%' e.g. '50%'\n        let ir = typeof innerRadius === 'number' ? innerRadius : (radius * (parseInt(innerRadius) || 0)) / 100\n        this.chart.innerRadius(ir)\n      }\n\n      if (useImprovedLabels) {\n        const buildArc = () => {\n          const maxRadius = Math.min(this.chart.width(), this.chart.height()) / 1.8\n          const radius = Math.min(this.chart.radius(), maxRadius)\n          return this.$d3.arc().outerRadius(radius).innerRadius(this.chart.innerRadius())\n        }\n\n        const labelPosition = (d, arc) => {\n          const centroid = arc.centroid(d)\n          if (centroid.some((coord) => isNaN(coord))) {\n            return [0, 0]\n          } else {\n            return centroid\n          }\n        }\n\n        const wrap = (text) => {\n          // take text `key;|;value` and transform to `key` and `(value)` on two lines\n          const d3 = this.$d3\n          const labelWrapSeparator = this.computedOptions.labelWrapSeparator\n          text.each(function () {\n            const el = d3.select(this)\n            const words = el.text().split(labelWrapSeparator)\n            if (!words || words.length < 2) {\n              return // no need to wrap. not enough words\n            }\n\n            const tString = el.attr('transform')\n            const x = parseFloat(tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n            const y = parseFloat(tString.slice(tString.indexOf(',') + 1, tString.indexOf(')')))\n            if (Number.isNaN(x) || Number.isNaN(y)) {\n              console.warn('unable to wrap text', tString, x, y, tString.slice(tString.indexOf('translate(') + 10, tString.indexOf(',')))\n              return\n            }\n            let tspan = el.text(null).append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 0)\n            tspan.text(words[0])\n            tspan = el.append('tspan').attr('transform', `translate(${x}, ${y})`).attr('x', 0).attr('y', 14)\n            tspan.text(`(${words[1].replace(/[^0-9\\-.]/g, '')})`)\n          })\n        }\n\n        const handleLabelTransition = () => {\n          this.chart.selectAll('text.pie-label').attr('transform', (d, i) => {\n            const arc = buildArc(this.chart)\n            const xy = labelPosition(d, arc)\n            let mult = (i + 1) / 6 + 0.3\n            if (xy[1] < 0) {\n              mult = 1\n            }\n            return `translate(${xy[0]}, ${xy[1] * mult})`\n          })\n          this.chart.selectAll('.pie-label-group text.pie-label').transition().call(wrap)\n        }\n\n        this.chart.on('renderlet.vue-dcjs', (_chart) => {\n          const radius = this.getRadius()\n          if (this.chart.radius() !== radius) {\n            this.chart.radius(radius)\n            this.chart.height(radius)\n            this.chart.width(radius)\n            this.chart.redraw()\n          }\n        })\n        this.chart.on('pretransition.vue-dcjs', handleLabelTransition)\n      }\n    },\n    render() {\n        this.$super(BaseChartMixin).render()\n        if (this.computedOptions.useImprovedLabels) {\n          this.$nextTick(() => {\n            this.chart.redraw() // fix label position\n          })\n        }\n    },\n    getRadius() {\n      let container = document.querySelector(`#chart-${this._uid}`)\n      if (!container) {\n        return 0\n      }\n      let suggestedRadius = container.clientWidth\n      // in flex containers, this was returning 0 always\n      // look outside the dc-chart-container element to see the available space there\n      if (!suggestedRadius && container.parentNode && container.parentNode.parentNode) {\n        let paddingOffset = 0\n        let node = container.parentNode.parentNode\n        try {\n          const nodeStyle = window.getComputedStyle(node, null)\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-left')) || 0\n          paddingOffset += parseInt(nodeStyle.getPropertyValue('padding-right')) || 0\n        } catch {\n          paddingOffset = 0\n        }\n        suggestedRadius = node.clientWidth - paddingOffset\n      }\n      let { minRadius, maxRadius } = this.computedOptions\n      return constrain(suggestedRadius, minRadius, maxRadius)\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-pie-chart .pie-slice:hover {\n  fill-opacity: 0.8;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-row-chart-container\">\n    <div :id=\"`chart-${_uid}`\" class=\"dc-chart dc-row-chart\" :class=\"{ 'is-scrollable': axisChart }\" :style=\"computedStyle\"></div>\n    <div v-show=\"canScroll\" :id=\"`chart-${_uid}-axis`\" class=\"dc-chart dc-axis-chart dc-row-axis-chart\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin } from '../../mixins'\nimport { accessorFunc } from '../../dc-utils.js'\n\nexport default {\n  name: 'DcRowChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin],\n  defaultOptions: {\n    elastic: true,\n    scrollable: true,\n    minHeight: 150,\n    barHeight: 20,\n    axisChartheight: 50,\n    scrollHeight: '200px',\n    scrollbarPadding: 0 // about the width of the scroll bar we are padding\n  },\n  data() {\n    return {\n      axisChart: null,\n      canScroll: false\n    }\n  },\n  methods: {\n    async createChart() {\n      // merge in default options\n      let { elastic, scrollable, minHeight, barHeight, axisChartHeight, valueAccessor, keyAccessor } = this.computedOptions\n      this.$options.dimension = this.createDimension()\n      const group = await this.createGroup(this.$options.dimension)\n      this.canScroll = scrollable && group.size() * barHeight > minHeight\n\n      this.chart = new this.$dc.RowChart(`#chart-${this._uid}`).dimension(this.$options.dimension).group(group)\n\n      this.$super(BaseChartMixin).createChart()\n      let rowChartMargin = this.canScroll ? Object.assign({}, this.computedMargins, { bottom: -1 }) : this.computedMargins\n      this.chart.margins(rowChartMargin)\n\n      if (elastic) {\n        this.chart.elasticX(true)\n      }\n\n      if (this.canScroll) {\n        this.chart.height(group.size() * barHeight)\n        this.chart.transitionDuration(1000)\n\n        let axisChartMargin = Object.assign({}, this.computedMargins, { top: 0 }) // enforce top margin\n        this.axisChart = new this.$dc.AxisChart(`#chart-${this._uid}-axis`)\n          .dimension(this.$options.dimension)\n          .group(group)\n          .height(axisChartHeight)\n          .margins(axisChartMargin)\n        if (valueAccessor) {\n          this.axisChart.valueAccessor(accessorFunc(valueAccessor))\n        }\n        if (keyAccessor) {\n          this.axisChart.keyAccessor(accessorFunc(keyAccessor))\n        }\n        if (elastic) {\n          this.axisChart.elastic(true)\n        }\n      }\n    },\n    render() {\n      this.$super(BaseChartMixin).render()\n      this.axisChart?.render()\n    },\n    callOnCreate() {\n      this.computedOptions?.onCreate?.(this.chart, this.axisChart)\n      this.$emit('create', this.chart, this.axisChart)\n    }\n  },\n  computed: {\n    computedStyle() {\n      let styles = []\n      if (this.canScroll) {\n        styles.push('overflow-y: auto; overflow-x: hidden;')\n        if (this.computedOptions.scrollHeight) {\n          styles.push(`max-height: ${this.computedOptions.scrollHeight}`)\n        }\n      }\n      return styles.join('; ')\n    },\n    computedMargins() {\n      let margins = Object.assign(\n        { top: 30, right: 30, bottom: 30, left: 30 },\n        this.$options.defaultOptions?.margins,\n        this.options?.margins\n      )\n      const { scrollbarPadding } = this.computedOptions\n      if (this.canScroll && scrollbarPadding) {\n        margins.right += scrollbarPadding\n      }\n      return margins\n    }\n  }\n}\n</script>\n\n<style>\n.dc-chart.dc-row-chart.is-scrollable > svg {\n  position: relative;\n  top: 6px;\n}\n.dc-chart.dc-row-chart.is-scrollable .axis path,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick text,\n.dc-chart.dc-row-chart.is-scrollable .axis g.tick line:not(.grid-line) {\n  display: none !important;\n  stroke: none;\n}\n</style>\n","<template>\n  <div class=\"dc-chart-container dc-stacked-bar-container\">\n    <div class=\"dc-chart dc-stacked-bar-chart\" :id=\"`chart-${_uid}`\"></div>\n  </div>\n</template>\n\n<script>\nimport { BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin } from '../../mixins'\nimport { accessorFunc, constrain } from '../../dc-utils'\n\nexport default {\n  name: 'DcStackedBarChart',\n  mixins: [BaseChartMixin, DimensionMixin, GroupMixin, AxisMixin, LegendMixin],\n  defaultOptions: {\n    elastic: true,\n    showLegend: true,\n    legendOptions: { x: 50 }\n  },\n  props: {\n    groups: {\n      // string[] left -> right x axis domain\n      type: Array,\n      required: true\n    },\n    stacks: {\n      // string[] | {name: string, color: string, key: string}[] bottom -> top group stack names for each key\n      type: Array,\n      required: true\n    },\n    colors: {\n      // string[], can also be provided in stacks.color (but only if every stack has provided a color value)\n      type: Array\n    },\n    keySeparator: {\n      type: String,\n      default: `;|;`\n    },\n    groupAccessor: {\n      type: [String, Function]\n    },\n    stackAccessor: {\n      type: [String, Function]\n    },\n    validateFunction: {\n      type: Function\n    }\n  },\n  methods: {\n    stackKey(stack) {\n      return typeof stack === 'string' ? stack : stack.key || stack.name || stack\n    },\n    stackName(stack) {\n      return typeof stack === 'string' ? stack : stack.name || stack.key || stack\n    },\n    computedValidateFunction(d, stack, group) {\n      if (this.validateFunction || this.computedOptions.validateFunction) {\n        let validate = this.validateFunction || this.computedOptions.validateFunction\n        return validate(d, stack, group)\n      } else {\n        const stackKey = this.stackKey(stack)\n        return this.stackAccessorFunc(d) === stackKey && this.groupAccessorFunc(d) === group\n      }\n    },\n    createChart() {\n      this.$options.dimension = this.ndx.dimension((d) => d)\n      let { add, remove, init } = this.stackReducer\n      const group = this.stackedGroup(this.$options.dimension.groupAll().reduce(add, remove, init))\n\n      const { elastic, title, barPadding, barGap, outerBarPadding } = this.computedOptions\n\n      this.chart = new this.$dc.BarChart(`#chart-${this._uid}`).dimension(this.$options.dimension)\n\n      this.$super(BaseChartMixin).createChart()\n      this.applyAxisOptions()\n      if (!this.computedAxisOptions.x?.x) {\n        this.chart.x(this.$d3.scaleBand().domain(this.groups))\n        this.chart.xUnits(this.$dc.units.ordinal)\n      }\n      let paddingDivisor = group.all().length || 1\n      this.chart.barPadding(constrain(2 / paddingDivisor, 0.1, 0.75))\n\n      if (barPadding !== undefined) {\n        this.chart.barPadding(barPadding)\n      } else if (barGap !== undefined) {\n        this.chart.gap(barGap)\n      }\n      if (outerBarPadding !== undefined) {\n        this.chart.outerPadding(outerBarPadding)\n      }\n\n      if (elastic) {\n        this.chart.elasticY(true)\n      }\n      if (this.computedColors.length) {\n        const colorScale = this.$d3\n          .scaleOrdinal()\n          .domain(this.stacks)\n          .range(this.stacks.map((stack, index) => this.computedColors[index % this.computedColors.length]))\n        this.chart.colors(colorScale)\n      }\n\n      function defaultTitleAccessor(d) {\n        return `${this.layer} ${d.key}: ${d.value[this.layer]}`\n      }\n      this.chart.title(accessorFunc(title || defaultTitleAccessor))\n\n      const keySeparator = this.keySeparator || ';|;'\n      const dc = this.$dc\n      this.chart.on('pretransition.vue-dcjs', function (chart) {\n        chart\n          .selectAll('rect.bar')\n          .classed('deselected', false)\n          .classed('stack-deselected', function (d) {\n            // display stack faded if the chart has filters AND\n            // the current stack is not one of them\n            var groupKey = d.layer + keySeparator + d.x\n            return chart.filter() && !chart.filters().some((f) => f[0] === groupKey)\n          })\n          .on('click', function (evt, d) {\n            // filter this stack (default is whole row)\n            chart.filter([d.layer + keySeparator + d.x])\n            dc.redrawAll()\n          })\n      })\n\n      this.stacks.forEach((stack, index) => {\n        const groupKey = this.stackKey(stack)\n        const action = index ? 'stack' : 'group' // the first stack is just .group, the rest are .stack\n        // FIXME is there ever a reason to do this? can we use a different method for constructing/reducing the dimension and fake group after?\n        this.chart[action](group, groupKey, (d) => d.value[groupKey])\n      })\n\n      this.chart.legendables = () => {\n        const chart = this.chart\n        return this.stacks.map((stack) => {\n          const name = this.stackName(stack)\n          const groupKey = this.stackKey(stack)\n          const color = this.chart.colors()(groupKey)\n          return { chart, name, color }\n        })\n      }\n\n      this.applyLegendOptions()\n\n      this.chart.filterHandler((dimension, filters) => {\n        if (filters && filters.length) {\n          dimension.filterFunction((record) => {\n            return filters.some((c) => {\n              const [stack, groupKey] = c[0].split(this.keySeparator || ';|;')\n              // FIXME let user override this\n              return this.computedValidateFunction(record, stack, groupKey)\n            })\n          })\n        } else {\n          dimension.filter(null)\n        }\n        return filters\n      })\n    },\n    stackedGroup(group) {\n      let keySeparator = this.keySeparator\n      return {\n        all: function () {\n          var all = Object.entries(group.value()).map(([key, value]) => ({ key, value }))\n          var m = {}\n          all.forEach((kv) => {\n            const [k, s] = kv.key.split(keySeparator)\n            m[k] = m[k] || {}\n            m[k][s] = kv.value\n          })\n          return Object.keys(m).map((key) => {\n            return { key, value: m[key] }\n          })\n        }\n      }\n    }\n  },\n  computed: {\n    computedColors() {\n      let colors = this.colors || []\n      if (this.stacks && this.stacks.length && this.stacks.every((stack) => stack.color)) {\n        colors = this.stacks.map((stack) => stack.color)\n      }\n      if (!colors.length && this.stacks && this.stacks.length) {\n        colors = this.stacks.map((stack, index) => this.$d3.interpolateTurbo((index + 0.5) / this.stacks.length))\n      }\n      return colors\n    },\n    stackReducer() {\n      return {\n        add: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] +=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        remove: (p, v) => {\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              if (this.computedValidateFunction(v, stack, group)) {\n                p[`${group}${this.keySeparator}${stackKey}`] -=\n                  accessorFunc(this.computedOptions.valueAccessor || ((d) => d.value))(v, stack, group) || 0\n              }\n            })\n          })\n          return p\n        },\n        init: () => {\n          const p = {}\n          this.groups.forEach((group) => {\n            this.stacks.forEach((stack) => {\n              let stackKey = this.stackKey(stack)\n              p[`${group}${this.keySeparator}${stackKey}`] = 0\n            })\n          })\n          return p\n        }\n      }\n    },\n    stackAccessorFunc() {\n      return accessorFunc(this.stackAccessor || this.computedOptions.stackAccessor || ((d) => d.stack))\n    },\n    groupAccessorFunc() {\n      return accessorFunc(this.groupAccessor || this.computedOptions.groupAccessor || ((d) => d.group))\n    }\n  }\n}\n</script>\n\n<style>\n.dc-stacked-bar-chart rect.bar.stack-deselected {\n  opacity: 0.2;\n}\n</style>\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install (Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport * from './mixins'\nexport { VueDc, dc, d3, crossfilter }\nexport default VueDc\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","calculateAxisScale","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","drawAxis","axisG","_g","select","empty","append","attr","transition","transitionDuration","transitionDelay","call","_doRender","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","axis","axisBottom","axisTop","axisRight","axisLeft","console","error","elastic","data","_doRedraw","constructor","parent","chartGroup","super","_defineProperty","_minHeight","_defaultHeightCalc","anchor","require","Object","assign","dc","renderAllNoTransitions","chartRegistry","list","forEach","chart","lastTransitionDuration","vueRender","render","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","_document$querySelect","_document$querySelect2","document","querySelector","closest","querySelectorAll","titleRoundDigits","dcConfig","DcPlugin","install","Vue","_options","options","setOptions","defaultColors","config","prototype","$dc","$d3","d3","$crossfilter","crossfilter","lastWidth","window","innerWidth","addEventListener","clearTimeout","setTimeout","script$c","name","props","axisOptions","autoTickHandler","methods","applyAxisOptions","_this$chart$xAxis","_this$chart","_this$chart$yAxis","_this$chart2","xAxisOptions","computedAxisOptions","x","yAxisOptions","y","xAxis","yAxis","applyTicks","ticks","applyFormat","format","tickFormat","applyValues","values","Array","isArray","tickValues","applySize","size","tickSize","tilt","classed","$options","dimension","autoTicks","ndx","onChange","evt","_this$chart3","_this$chart4","_group$top","_group$top$call","maxTicks","Math","max","valueAccessor","group","maxValue","ceil","min","computed","_this$computedOptions","_this$axisOptions","_this$computedOptions2","_this$axisOptions2","_this$computedOptions3","_this$axisOptions3","computedOptions","beforeDestroy","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","shadowRoot","originalRender","h","existing","beforeCreate","concat","isOldIE","navigator","test","userAgent","toLowerCase","id","css","media","styles","ids","Set","has","code","source","map","sources","btoa","unescape","encodeURIComponent","JSON","stringify","element","createElement","setAttribute","undefined","HEAD","head","getElementsByTagName","appendChild","push","styleSheet","cssText","filter","Boolean","join","index","textNode","createTextNode","nodes","childNodes","removeChild","insertBefore","addStyle","accessorFunc","accessor","constrain","target","minValue","Infinity","required","String","baseDefaultOptions","disposeDimension","resetButtonFunction","resetButtons","mounted","reset","[object Object]","createChart","addChartExtras","callOnCreate","onFilter","on","onClick","setupResetListener","renderChart","keyAccessor","title","label","height","width","digits","titleSuffix","titleDigits","_value","key","value","toFixed","computedMargins","onResetButtonClick","Promise","resolve","$emit","$nextTick","vueOptions","onCreate","charts","children","reduce","buttons","result","res","filterAll","redrawAll","button","updateButtonVisibility","hasFilter","some","instance","classList","remove","e","margin","right","bottom","_this$$options$defaul","_this$options","dim","deregister","dispose","dimensionConstructor","Function","dimensionIsArray","default","createDimension","dimensionAccessor","pluck","reducer","groupOptions","createGroup","groupAll","order","orderNatural","reduceSum","init","_reject","resolveTimeout","replaceGroup","ordinalToLinear","valueFunc","isGroupAll","_ord2int","_int2ord","number","entries","sort","a","b","slice","all","ret","ord2int","o","int2ord","callback","num","legend","legendOptions","applyLegendOptions","showLegend","autoWidth","gap","highlightSelected","horizontal","itemHeight","itemWidth","keyboardAccessible","legendText","legendWidth","maxItems","computedLegendOptions","autoItemWidth","_this$defaultOptions","mixins","BaseChartMixin","DimensionMixin","GroupMixin","AxisMixin","scrollable","minScrollable","scrollHeight","mouseZoom","scaleChart","hasReplacedRenderFunc","_this$computedAxisOpt","filterFunction","barPadding","barGap","outerBarPadding","ordinalValueAccessor","v","linearDomain","defaultBarGap","_uid","clientWidth","BarChart","xUnits","units","integers","centerBar","brushOn","$super","kv","canScroll","elasticY","xAxisFormat","l","focusFilter","filterHandler","_dimension","_filters","f","every","includes","applyFilter","k","_listeners","filters","_originalReplaceFilter","replaceFilter","fadeDeselectedArea","_brushSelection","bars","chartBodyG","selectAll","constants","SELECTED_CLASS","DESELECTED_CLASS","splice","redrawGroup","floor","rescale","outerPadding","_invokeFilteredListener","filterType","rangeChart","zoomScale","mouseZoomable","_this$scaleChart","_preprocessData","_generateG","_generateClipPath","_drawChart","maxEnd","focus","searchable","search","othersLimit","Number","maxHeight","othersLabel","forceFilter","keyDisplay","groupFilter","groups","others","inFilter","waitInterval","waitingTimer","dcChart","waitForChartInit","watch","_to","_from","formatFilter","resetFilters","updateListValues","watchChartChanges","array","from","acc","val","parse","slicesCap","checkOthersFilterToggled","currentFilters","fixFilters","toggleFilterFor","updateSearch","firstTry","setInterval","clearInterval","find","c","displayKey","option","shownGroups","g","RegExp","computedDigits","computedStyle","_this$dcChart","LegendMixin","groupCharts","renderArea","CompositeChart","groupChart","LineChart","color","colors","compose","limitTicksToNumDays","useD3TimeDay","snapDateCalculation","useUtcSnapping","fakeGroupingSettings","getDateBounds","date","Date","startDate","endDate","setUTCHours","setHours","days","abs","daysDifference","d1","d2","getTime","timeDay","fakeGroup","original","originalDays","toISOString","fillValue","thisDate","setDate","getDate","scaleTime","NumberDisplay","anchorName","html","singular","plural","formatNumber","makeValueAccessor","one","none","minRadius","maxRadius","innerRadius","useImprovedLabels","labelWrapSeparator","PieChart","externalRadiusPadding","radius","getRadius","ir","parseInt","buildArc","arc","outerRadius","labelPosition","centroid","coord","isNaN","wrap","text","each","el","words","split","tString","parseFloat","warn","tspan","replace","handleLabelTransition","xy","mult","_chart","redraw","container","suggestedRadius","parentNode","paddingOffset","node","nodeStyle","getComputedStyle","getPropertyValue","minHeight","barHeight","axisChartheight","scrollbarPadding","axisChart","axisChartHeight","RowChart","rowChartMargin","elasticX","axisChartMargin","_this$axisChart","stacks","keySeparator","groupAccessor","stackAccessor","validateFunction","stackKey","stack","stackName","computedValidateFunction","stackAccessorFunc","groupAccessorFunc","stackReducer","stackedGroup","scaleBand","ordinal","paddingDivisor","computedColors","colorScale","scaleOrdinal","layer","groupKey","action","legendables","record","m","s","keys","interpolateTurbo","p","registerComponents","VueDc","Proxy","get","bind","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}