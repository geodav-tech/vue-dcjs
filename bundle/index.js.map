{"version":3,"file":"index.js","sources":["../src/plugins/axis-chart.class.js","../src/plugins/dc.plugin.js","../src/dc-utils.js","../src/mixins/base-chart.mixin.vue","../src/index.js"],"sourcesContent":["import { CapMixin, ColorMixin, MarginMixin, transition } from 'dc'\nimport { axisBottom, extent as d3Extent, scaleLinear } from 'd3'\n\n// https://gist.github.com/ialarmedalien/ebca7eeb67c6d0b0a7809c46ef160cd0\n// Adapted into a class implementation by shawn@geodav.tech\n/**\n * Separate axis implementation.\n *\n * Examples:\n * - {@link https://bl.ocks.org/ialarmedalien/0a4bf25ffc0fb96ae569a20f91957bc1 eslint on dc.js source}\n * @class AxisChart\n * @example\n * // create an axis under #chart-container1 element using the default global chart group\n * var chart1 = new AxisChart('#chart-container1');\n * // create an axis under #chart-container2 element using chart group A\n * var chart2 = new AxisChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-selection d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n */\nexport class AxisChart extends CapMixin(ColorMixin(MarginMixin)) {\n  _g\n  _scale\n  _elastic\n  _type = 'axisBottom'\n  _theAxis = axisBottom()\n  _axisData\n  validAxisTypes = ['axisBottom', 'axisTop', 'axisLeft', 'axisRight']\n  axisCap\n\n  calculateAxisScale() {\n    if (!this._scale || this._elastic) {\n      var extent = d3Extent(this._axisData, (d, i) => this.cappedValueAccessor(d, i))\n      if (extent[0] > 0) {\n        extent[0] = 0\n      }\n      if (extent[1] < 0) {\n        extent[1] = 0\n      }\n      this._scale = scaleLinear()\n        .domain(extent)\n        .range([0, this._type === 'axisBottom' || this._type === 'axisTop' ? this.effectiveWidth() : this.effectiveHeight()])\n    }\n    this._theAxis.scale(this._scale)\n  }\n\n  drawAxis() {\n    var axisG = this._g.select('g.axis')\n\n    this.calculateAxisScale()\n\n    if (axisG.empty()) {\n      axisG = this._g.append('g').attr('class', 'axis')\n    }\n\n    transition(axisG, this.transitionDuration(), this.transitionDelay()).call(this._theAxis)\n  }\n\n  _doRender() {\n    this.minHeight(1)\n    this.height(50)\n    // idk why the minHeight, height kept getting reset\n    // so you must call these before resetSvg()\n    // otherwise the axisHeight is like 200px or 156px (depending on minHeight)\n    this.resetSvg()\n    this._g = this.svg().append('g').attr('transform', `translate(${this.margins().left}, ${this.margins().top})`)\n    this.drawChart()\n    return this\n  }\n\n  /**\n   * Gets or sets the axis type. The axis type can be any valid\n   * {@link https://github.com/d3/d3-axis d3 axis}. The default is\n   * axisBottom (a bottom axis).\n   * @see {@link https://github.com/d3/d3-axis d3 axis}\n   * @param {d3.type} [type]\n   * @returns {string|dc.axisChart} no args: type string; args: axis chart\n   */\n  type(type) {\n    if (!arguments.length) {\n      return this._type\n    }\n    if (this.validAxisTypes.indexOf(type) !== -1) {\n      this._theAxis = d3[type]()\n      this._type = type\n    } else {\n      console.error(type + ' is not a valid d3 axis type')\n    }\n    return this\n  }\n\n  /**\n   * Gets or sets the axis scale. The axis scale can be any d3\n   * {@link https://github.com/d3/d3-scale quantitative scale}.\n   * @see {@link https://github.com/d3/d3-scale quantitative scale}\n   * @param {d3.scale} [scale] any value d3 scale\n   * @returns {d3.scale|dc.axisChart} no args: chart scale; args: axis chart\n   */\n  scale(scale) {\n    if (!arguments.length) {\n      return this._scale\n    }\n    this._scale = scale\n    return this\n  }\n\n  /**\n   * Get or set the elasticity on the axis. If this attribute is set to true,\n   * then the axis will rescale to auto-fit the data range when filtered.\n   * @param {Boolean} [elastic] any valid boolean\n   * @returns {Boolean|dc.axisChart} no args: boolean; args: axis chart\n   */\n  elastic(elastic) {\n    if (!arguments.length) {\n      return this._elastic\n    }\n    this._elastic = elastic\n    return this\n  }\n\n  /**\n   * Get the axis for the axis chart instance.\n   * See the {@link https://github.com/d3/d3-axis d3 axis object}\n   * documention for more information.\n   * @see {@link https://github.com/d3/d3-axis d3.axis}\n   * @example\n   * // customize axis tick format\n   * chart.axis().tickFormat(function (v) {return v + '%';});\n   * // customize axis tick values\n   * chart.axis().tickValues([0, 100, 200, 300]);\n   * @returns {d3.axis} d3 axis\n   */\n  axis() {\n    return this._theAxis\n  }\n\n  drawChart() {\n    this._axisData = this.data()\n    this.drawAxis()\n  }\n\n  _doRedraw() {\n    this.drawChart()\n    return this\n  }\n\n  constructor(parent, chartGroup) {\n    super(parent, chartGroup)\n    this.anchor(parent, chartGroup)\n  }\n}\n","import * as dc from 'dc'\nimport * as d3 from 'd3'\nimport crossfilter from 'crossfilter2'\nimport { AxisChart } from './axis-chart.class'\nrequire('dc/dist/style/dc.min.css')\n\ndc.AxisChart = AxisChart\n\nconst defaultOptions = {\n  // defaultColors: string[] of colors for ordinal charts\n  useWindowResize: true, // on window resize, resize the charts to best fit their space\n  resizeTimeout: 100, // wait at least this many ms to resize the charts (prevents glitching when slowly resizing the window)\n  // default this to work in the example\n  useResetListener: true, // use this.chart.on('filtered.reset') and the resetSelector to determine show/hide the reset button\n  resetSelector: chart => document.querySelector(chart.anchor()).closest('.example-container').querySelectorAll('.example-reset-button')\n}\n\n/**\n * import DcPlugin from 'this.file'\n * Vue.use(DcPlugin)\n *\n * binds dc, d3, and crossfilter to vue via $dc, $d3, $crossfilter\n */\nconst DcPlugin = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, _options)\n\n    Vue.prototype.$VueDcOptions = options // let us access these options later\n\n    if (options?.defaultColors) {\n      dc.config.defaultColors(options.defaultColors)\n    }\n\n    Vue.prototype.$dc = dc\n    Vue.prototype.$d3 = d3\n    Vue.prototype.$crossfilter = crossfilter\n\n    if (options.useWindowResize) {\n      let resizeTimeout = null\n      // I don't think there's really any way for us to know when/how to destroy this, so I'm assuming vue will figure it out\n      // most likely this is only destroyed when you leave the page and everything is destroyed anyway\n      window.addEventListener('resize', () => {\n        if (resizeTimeout) {\n          clearTimeout(resizeTimeout)\n        }\n        resizeTimeout = setTimeout(() => {\n          dc.renderAll()\n          resizeTimeout = null\n        }, options.resizeTimeout)\n      })\n    }\n  }\n}\n\nexport default DcPlugin\nexport { DcPlugin, dc, d3, crossfilter }\n","/**\n *\n * @param {String | Function} accessor used for keyAccessor valueAccessor, label, title, etc.\n * @returns {Function} to use like this.chart.keyAccessor(accessorFunc(keyAccessor))\n */\nexport function accessorFunc(accessor) {\n  return typeof accessor === 'function' ? accessor : (d) => d[accessor]\n}\n\n/**\n *\n * @param {Number} target the value you wish to ensure is within the bounds\n * @param {Number} minValue the minimum returned value (inclusive)\n * @param {Number} maxValue the maximum returned value (inclusive)\n * @returns {Number} the target value, limited to the bounds provided by min/max inclusively\n */\nexport function constrain(target, minValue = -Infinity, maxValue = Infinity) {\n  return Math.max(minValue, Math.min(target, maxValue))\n}\n\n/**\n *\n * @param {Array} array 2d+ array\n * @returns  1d array\n */\nexport function flat(array) {\n  if (!Array.isArray(array)) {\n    return []\n  }\n  return array.reduce((acc, val) => acc.concat(val), [])\n}\n","<script>\nimport { accessorFunc } from '../dc-utils.js'\nexport default {\n  name: 'BaseChartMixin',\n  dimension: null, //crossfilter.dimension\n  myName: 'baseChart',\n  props: {\n    ndx: {\n      // crossfilter object. e.g. this.$crossfilter(dataArray)\n      type: Object,\n      required: true\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object\n    }\n  },\n  baseDefaultOptions: {\n    disposeDimension: true,\n    render: true // set false to stop rendering on startup\n    // beforeDestroy: dimension.dispose()\n    // valueAccessor: string, function,\n    // margins: {top, left, bottom, right},\n    // keyAccessor: string, function,\n    // title: string, function,\n    // label: string, function\n  },\n  data() {\n    return {\n      chart: null,\n      resetButtonFunction: null,\n      resetButtons: [],\n    }\n  },\n  mounted() {\n    this.drawChart()\n  },\n  methods: {\n    reset() {\n      if (this.chart) {\n        this.chart.filter(null)\n      }\n    },\n    drawChart() {\n      // clear chart?\n      this.createChart()\n      this.addChartExtras()\n\n      this.callOnCreate()\n\n      if (this.computedOptions.onFilter) {\n        this.chart.on('filtered', this.computedOptions.onFilter)\n      }\n      if (this.computedOptions.onClick) {\n        this.chart.on('click', this.computedOptions.onClick)\n      }\n\n      if (this.$VueDcOptions.useResetListener && typeof this.$VueDcOptions.resetSelector === 'function') {\n        this.setupResetListener()\n      }\n\n      if (this.computedOptions.render) {\n        this.renderChart()\n      }\n    },\n    /**\n     * you are able to call this.$super(BaseChartMixin).drawChart()\n     * but you must create the chart first\n     */\n    createChart() {\n      const { valueAccessor, margins, keyAccessor, title, label, height, width } = this.computedOptions\n      if (valueAccessor) {\n        this.chart.valueAccessor(accessorFunc(valueAccessor))\n      }\n      if (margins) {\n        this.chart.margins(this.computedMargins)\n      }\n      if (keyAccessor) {\n        this.chart.keyAccessor(accessorFunc(keyAccessor))\n      }\n      if (title) {\n        this.chart.title(accessorFunc(title))\n      }\n      if (label) {\n        this.chart.label(accessorFunc(label))\n      }\n\n      if (height) {\n        this.chart.height(height)\n      }\n      if (width) {\n        this.chart.width(width)\n      }\n    },\n    onResetButtonClick() {\n\n    },\n    // allows children to hook into pre/post render hooks\n    renderChart() {\n      return new Promise((resolve) => {\n        this.$emit('pre-render', this.chart)\n        this.$nextTick(() => {\n          this.render()\n          this.$nextTick(() => {\n            this.$emit('post-render', this.chart)\n            return resolve(this.chart)\n          })\n        })\n      })\n    },\n    render() {\n      // to be extended by children if needed\n      this.chart.render()\n    },\n    addChartExtras() {\n      if (this.name || this.computedOptions.name) {\n        this.chart.name = this.name || this.computedOptions.name\n      }\n      // set chart.vueOptions to be able to pass chart without having to additionally pass it's computedOptions\n      this.chart.vueOptions = this.computedOptions\n    },\n    callOnCreate() {\n      // charts with multiple components may wish to pass extras. make this an overridable function\n      this.$emit('on-create', this.chart)\n    },\n    setupResetListener () {\n      const { resetSelector } = this.$VueDcOptions\n      let resetButtons = resetSelector(this.chart)\n      if (typeof resetButtons.forEach !== 'function') {\n        resetButtons = [resetButtons]\n      }\n      this.resetButtons = resetButtons // store this for later to de-register\n\n      // ensure we can remove this later\n      this.resetButtonFunction = () => {\n        this.chart.filterAll()\n        this.$dc.redrawAll()\n      }\n\n      resetButtons.forEach(button => {\n        button.addEventListener('click', this.resetButtonFunction)\n      })\n\n      const updateButtonVisibility = () => {\n        let hasFilter = this.chart.hasFilter()\n        this.resetButtons.forEach(instance => {\n          if (hasFilter) {\n            instance.classList.remove('dc-reset-is-hidden')\n          } else {\n            instance.classList.add('dc-reset-is-hidden')\n          }\n        })\n      }\n\n      this.chart.on('filtered.reset', updateButtonVisibility)\n      updateButtonVisibility() // update this on startup as well\n    }\n  },\n  computed: {\n    computedMargins() {\n      if (typeof this.computedOptions.margins === 'number') {\n        let margin = this.computedOptions.margins\n        return { top: margin, left: margin, right: margin, bottom: margin }\n      } else {\n        return Object.assign({ top: 30, right: 30, bottom: 30, left: 30 }, this.$options.defaultOptions?.margins, this.options?.margins)\n      }\n    },\n    computedOptions() {\n      return Object.assign({}, this.$options.baseDefaultOptions, this.$options.defaultOptions, this.options)\n    }\n  },\n  beforeDestroy() {\n    if (this.chart) {\n      // fix problems where things that change keys have filters that you can never recover data from\n      // clear all filters from dimension when chart is destroyed.\n      // this may want to become optional if:\n      //    charts share a dimension where:\n      //        one or more is expected to be destroyed\n      //        and one or more is expected to retain filtered state\n      const dim = this.chart.dimension()\n      if (dim) {\n        // FIXME store these and reapply filters?\n        dim.filterAll()\n      }\n      // we also cannot dispose of dimensions for this reason.\n      // though some charts should have an option for this\n      // all dc instances share a registry. take care of yourself\n      this.$dc.chartRegistry.deregister(this.chart)\n    }\n    if (this.computedOptions.disposeDimension && this.$options.dimension) {\n      this.$options.dimension.dispose()\n    }\n  }\n}\n</script>\n\n<style>\n.dc-reset-is-hidden {\n  display: none !important;\n}\n</style>\n","// it seems important to use FULL filenames with extensions\nimport { DcPlugin, dc, d3, crossfilter } from './plugins/dc.plugin.js'\nimport {\n  DcBarChart,\n  DcChecklist,\n  DcCompositeLineChart,\n  DcDateChart,\n  DcNumberDisplay,\n  DcPieChart,\n  DcRowChart,\n  DcStackedBarChart\n} from './components'\n\nconst defaultOptions = {\n  registerComponents: true // Vue.component(everything) by default? will use dc-chart-name for prefixes\n  // defaultColors: for dc.defaultOptions.defaultColors\n  // useWindowResize: window.addEventListener(resize => dc.renderAll())\n  // resizeTimeout how long to wait before calling the renderAll. prevents glitchy re-rendering if lots of resize events fire\n}\n\nconst VueDc = {\n  install(Vue, _options) {\n    const options = Object.assign({}, defaultOptions, options)\n    // hmm do we prevent this from polluting the namespace?\n    // what if the user overrides $super in their code??\n    // https://forum.vuejs.org/t/call-the-overrided-method-from-extend-mixin-think-super/1469\n    // https://github.com/iashraful/vue-super-call/blob/master/index.js\n    Vue.prototype.$super = function (options) {\n      return new Proxy(options, {\n        get: (options, name) => {\n          if (options.methods && name in options.methods) {\n            return options.methods[name].bind(this)\n          }\n        }\n      })\n    }\n\n    // register $dc, $d3, $crossfilter\n    // also set up window resize watcher if specified\n    Vue.use(DcPlugin, options)\n\n    // register out of the box components\n    if (options.registerComponents) {\n      Vue.component('dc-bar-chart', DcBarChart)\n      Vue.component('dc-checklist', DcChecklist)\n      Vue.component('dc-composite-line-chart', DcCompositeLineChart)\n      Vue.component('dc-date-chart', DcDateChart)\n      Vue.component('dc-number-display', DcNumberDisplay)\n      Vue.component('dc-pie-chart', DcPieChart)\n      Vue.component('dc-row-chart', DcRowChart)\n      Vue.component('dc-stacked-bar-chart', DcStackedBarChart)\n    }\n  }\n}\n\n// fix warning prefer_named_exports by naming this export\nexport * from './components'\nexport { VueDc, dc, d3, crossfilter }\n"],"names":["AxisChart","CapMixin","ColorMixin","MarginMixin","parent","chartGroup","axisBottom","anchor","this","_scale","_elastic","extent","d3Extent","_axisData","d","i","_this2","cappedValueAccessor","scaleLinear","domain","range","_type","effectiveWidth","effectiveHeight","_theAxis","scale","axisG","_g","select","calculateAxisScale","empty","append","attr","transition","transitionDuration","transitionDelay","call","minHeight","height","resetSvg","svg","margins","left","top","drawChart","type","arguments","length","validAxisTypes","indexOf","d3","console","error","elastic","data","drawAxis","require","dc","defaultOptions","useWindowResize","resizeTimeout","useResetListener","resetSelector","chart","document","querySelector","closest","querySelectorAll","DcPlugin","install","Vue","_options","options","Object","assign","prototype","$VueDcOptions","defaultColors","config","$dc","$d3","$crossfilter","crossfilter","window","addEventListener","clearTimeout","setTimeout","renderAll","accessorFunc","accessor","constrain","target","minValue","Infinity","maxValue","Math","max","min","array","Array","isArray","reduce","acc","val","concat","registerComponents","VueDc","$super","Proxy","get","name","methods","bind","_this","use","component","DcBarChart","DcChecklist","DcCompositeLineChart","DcDateChart","DcNumberDisplay","DcPieChart","DcRowChart","DcStackedBarChart"],"mappings":"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"}